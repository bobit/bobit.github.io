<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bobit-你好世界</title>
  
  <subtitle>做一个有心人，总结经验和教训。#副标题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bobit.github.io/"/>
  <updated>2018-12-27T15:12:05.175Z</updated>
  <id>https://bobit.github.io/</id>
  
  <author>
    <name>Bobit</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty入门</title>
    <link href="https://bobit.github.io/posts/21d654b6.html"/>
    <id>https://bobit.github.io/posts/21d654b6.html</id>
    <published>2017-12-13T14:29:17.000Z</published>
    <updated>2018-12-27T15:12:05.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Netty 是一个异步和事件驱动的网络框架，用以快速开发高性能、高可靠性的网络服务器和客户端程序。也就是说，Netty 是一个基于 NIO 的客户、服务器端编程框架，使用 Netty 可以确保你快速和简单地开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty 相当简化和流线化了网络应用的编程开发过程，例如，TCP 和 UDP 的 socket 服务开发。</p><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><p>（摘自《Netty in Action》）</p><p>1）设计<br>统一的API，适用于不同的协议（阻塞和非阻塞）<br>基于灵活、可扩展的事件驱动模型<br>高度可定制的线程模型<br>可靠的无连接数据Socket支持（UDP）<br>2）性能<br>更好的吞吐量，低延迟<br>更省资源<br>尽量减少不必要的内存拷贝<br>3）安全<br>完整的SSL/TLS和STARTTLS的支持<br>能在Applet与Android的限制环境运行良好<br>4）健壮性<br>不再因过快、过慢或超负载连接导致OutOfMemoryError<br>不再有在高速网络环境下NIO读写频率不一致的问题<br>5）易用<br>完善的JavaDoc，用户指南和样例<br>简洁简单<br>仅信赖于JDK1.5</p><h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2><p>Netty是一个高性能 事件驱动的异步的非堵塞的IO(NIO)框架，用于建立TCP等底层的连接，基于Netty可以建立高性能的Http服务器。支持HTTP、 WebSocket 、Protobuf、 Binary TCP 和UDP，Netty已经被很多高性能项目作为其Socket底层基础，其竞争对手是：Apache MINA和 Grizzly。</p><h3 id="互联网行业"><a class="markdownIt-Anchor" href="#互联网行业"></a> 互联网行业</h3><p>随着网站规模的不断扩大，系统并发访问量也越来越高，传统基于 Tomcat 等 Web 容器的垂直架构已经无法满足需求，需要拆分应用进行服务化，以提高开发和维护效率。从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。</p><p>典型的应用有：</p><ul><li>阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。其中，服务提供者和服务消费者之间，服务提供者、服务消费者和性能统计节点之间使用 Netty 进行异步/同步通信。</li><li>除了 Dubbo 之外，淘宝的消息中间件 RocketMQ 的消息生产者和消息消费者之间，也采用 Netty 进行高性能、异步通信。</li><li>除了阿里系和淘宝系之外，很多其它的大型互联网公司或者电商内部也已经大量使用 Netty 构建高性能、分布式的网络服务器。</li></ul><h3 id="游戏行业"><a class="markdownIt-Anchor" href="#游戏行业"></a> 游戏行业</h3><p>无论是手游服务端、还是大型的网络游戏，Java 语言得到了越来越广泛的应用。Netty 作为高性能的基础通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过 Netty 进行高性能的通信。</p><h3 id="大数据领域"><a class="markdownIt-Anchor" href="#大数据领域"></a> 大数据领域</h3><p>经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨节点通信，它的 Netty Service 基于 Netty 框架二次封装实现。<br>大数据计算往往采用多个计算节点和一个/N个汇总节点进行分布式部署，各节点之间存在海量的数据交换。由于 Netty 的综合性能是目前各个成熟 NIO 框架中最高的，因此，往往会被选中用作大数据各节点间的通信。</p><h3 id="企业软件"><a class="markdownIt-Anchor" href="#企业软件"></a> 企业软件</h3><p>企业和 IT 集成需要 ESB，Netty 对多协议支持、私有协议定制的简洁性和高性能是 ESB RPC 框架的首选通信组件。事实上，很多企业总线厂商会选择 Netty 作为基础通信组件，用于企业的 IT 集成。</p><h3 id="通信行业"><a class="markdownIt-Anchor" href="#通信行业"></a> 通信行业</h3><p>Netty 的异步高性能、高可靠性和高成熟度的优点，使它在通信行业得到了大量的应用。</p><h2 id="核心组件"><a class="markdownIt-Anchor" href="#核心组件"></a> 核心组件</h2><ul><li>Channel</li><li>ChannelFuture</li><li>EventLoop</li><li>ChannelHandler</li><li>ChannelPipeline</li></ul><h4 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h4><p>Channel 是 Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 之外，还包括了 Netty 框架相关的一些功能，如获取该 Channe l的 EventLoop。</p><p>在传统的网络编程中，作为核心类的 Socket ，它对程序员来说并不是那么友好，直接使用其成本还是稍微高了点。而Netty 的 Channel 则提供的一系列的 API ，它大大降低了直接与 Socket 进行操作的复杂性。而相对于原生 NIO 的 Channel，Netty 的 Channel 具有如下优势（摘自《Netty权威指南（第二版）》）：</p><ul><li>在 Channel 接口层，采用 Facade 模式进行统一封装，将网络 I/O 操作、网络 I/O 相关联的其他操作封装起来，统一对外提供。</li><li>Channel 接口的定义尽量大而全，为 SocketChannel 和 ServerSocketChannel 提供统一的视图，由不同子类实现不同的功能，公共功能在抽象父类中实现，最大程度地实现功能和接口的重用。</li><li>具体实现采用聚合而非包含的方式，将相关的功能类聚合在 Channel 中，有 Channel 统一负责和调度，功能实现更加灵活。</li></ul><h4 id="eventloop"><a class="markdownIt-Anchor" href="#eventloop"></a> EventLoop</h4><p>Netty 基于事件驱动模型，使用不同的事件来通知我们状态的改变或者操作状态的改变。它定义了在整个连接的生命周期里当有事件发生的时候处理的核心抽象。</p><p>Channel 为Netty 网络操作抽象类，EventLoop 主要是为Channel 处理 I/O 操作，两者配合参与 I/O 操作。</p><p>下图是Channel、EventLoop、Thread、EventLoopGroup之间的关系（摘自《Netty In Action》）：</p><p><img src="../../../gitbooks/static/images/21d654b6/616953-20170509162546738-1955835364.png" alt="img"></p><ul><li>一个 EventLoopGroup 包含一个或多个 EventLoop。</li><li>一个 EventLoop 在它的生命周期内只能与一个Thread绑定。</li><li>所有有 EnventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理。</li><li>一个 Channel 在它的生命周期内只能注册与一个 EventLoop。</li><li>一个 EventLoop 可被分配至一个或多个 Channel 。</li></ul><p>当一个连接到达时，Netty 就会注册一个 Channel，然后从 EventLoopGroup 中分配一个 EventLoop 绑定到这个Channel上，在该Channel的整个生命周期中都是有这个绑定的 EventLoop 来服务的。</p><h4 id="channelfuture"><a class="markdownIt-Anchor" href="#channelfuture"></a> ChannelFuture</h4><p>Netty 为异步非阻塞，即所有的 I/O 操作都为异步的，因此，我们不能立刻得知消息是否已经被处理了。Netty 提供了 ChannelFuture 接口，通过该接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。</p><h4 id="channelhandler"><a class="markdownIt-Anchor" href="#channelhandler"></a> ChannelHandler</h4><p>ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p><p>ChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站数据和事件，而 ChannelOutboundHandler 则相反。</p><h4 id="channelpipeline"><a class="markdownIt-Anchor" href="#channelpipeline"></a> ChannelPipeline</h4><p>ChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。一个数据或者事件可能会被多个 Handler 处理，在这个过程中，数据或者事件经流 ChannelPipeline，由 ChannelHandler 处理。在这个处理过程中，一个 ChannelHandler 接收数据后处理完成后交给下一个 ChannelHandler，或者什么都不做直接交给下一个 ChannelHandler。</p><p>当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</p><p>当 ChannelHandler 被添加到 ChannelPipeline 时，它将会被分配一个 ChannelHandlerContext，它代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。其中 ChannelHandler 添加到 ChannelPipeline 过程如下：</p><ol><li>一个 ChannelInitializer 的实现被注册到了 ServerBootStrap中</li><li>当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer 将在 ChannelPipeline 中安装一组自定义的 ChannelHandler</li><li>ChannelInitializer 将它自己从 ChannelPipeline 中移除</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;Netty 是一个异步和事件驱动的网络框架，用以快速开发高性能、高可靠性的网络服务器和客户端程序。也就是说，Netty 是一个基于 NIO 的客
      
    
    </summary>
    
      <category term="分布式" scheme="https://bobit.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Netty" scheme="https://bobit.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Netty/"/>
    
    
      <category term="Netty" scheme="https://bobit.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>互联网常用名词大全</title>
    <link href="https://bobit.github.io/posts/9253509e.html"/>
    <id>https://bobit.github.io/posts/9253509e.html</id>
    <published>2017-11-13T14:29:17.000Z</published>
    <updated>2018-12-24T05:54:17.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="devops"><a class="markdownIt-Anchor" href="#devops"></a> DevOps</h2><p>Development和Operations的组合词</p><h2 id="paasplatform-as-a-service"><a class="markdownIt-Anchor" href="#paasplatform-as-a-service"></a> PaaS（Platform-as-a-Service）</h2><p>平台即服务</p><h2 id="tlteam-leader"><a class="markdownIt-Anchor" href="#tlteam-leader"></a> TL（Team Leader）</h2><h2 id="pmproject-manager"><a class="markdownIt-Anchor" href="#pmproject-manager"></a> PM（Project Manager）</h2><h2 id="pmoproject-management-officer"><a class="markdownIt-Anchor" href="#pmoproject-management-officer"></a> PMO（Project Management Officer）</h2><p>一般称为项目管理办公室、项目管理中心或者项目管理部</p><h2 id="iaasinfrastructure-as-a-service"><a class="markdownIt-Anchor" href="#iaasinfrastructure-as-a-service"></a> IaaS（Infrastructure-as-a-Service）</h2><p>基础设施即服务</p><h2 id="saassoftware-as-a-service"><a class="markdownIt-Anchor" href="#saassoftware-as-a-service"></a> SaaS（Software-as-a-Service(）</h2><p>软件即服务</p><h2 id="pvpage-view"><a class="markdownIt-Anchor" href="#pvpage-view"></a> PV（page view）</h2><p>页面浏览量，用户每一次对网站中的每个页面访问均被记录1次。用户对同一页面的多次刷新，访问量累计。<br>单台服务器每天PV计算<br>公式1：每天总PV = QPS * 3600 * 6<br>公式2：每天总PV = QPS * 3600 * 8</p><h2 id="uvunique-visitor"><a class="markdownIt-Anchor" href="#uvunique-visitor"></a> UV（Unique  Visitor）</h2><p>独立访客    通过客户端的cookies实现。访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次 。即同一页面，客户端多次点击只计算一次，访问量不累计。<br>服务器数量：<br>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器<br>机器：ceil( 每天总PV / 单台服务器每天总PV )</p><h2 id="ipinternet-protocol"><a class="markdownIt-Anchor" href="#ipinternet-protocol"></a> IP（Internet Protocol）</h2><p>本意本是指网络协议，在数据统计这块指通过ip的访问量。即同一页面，客户端使用同一个IP访问多次只计算一次，访问量不累计。</p><p><strong>UV、IP的区别</strong></p><ol><li>比如你是ADSL拨号上网，拨一次号自动分配一个IP，进入了网站，就算一个IP；断线了而没清理Cookies，又拨号一次自动分配一个IP，又进入了同一个网站，又统计到一个IP，这时统计数据里IP就显示统计了2次。UV没有变，是1次。</li><li>同一个局域网内2个人，在2台电脑上访问同一个网站，他们的公网IP是相同的。IP就是1，但UV是2。</li></ol><h2 id="tpstransactions-per-second"><a class="markdownIt-Anchor" href="#tpstransactions-per-second"></a> TPS（Transactions Per Second）</h2><p>每秒处理的事务数目。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息作出的评估分。</p><h2 id="qpsqueries-per-second"><a class="markdownIt-Anchor" href="#qpsqueries-per-second"></a> QPS（Queries Per Second）</h2><p>每秒能处理查询数目，也即是最大吞吐能力。是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。<br>QPS统计方式 [一般使用 http_load 进行统计]<br>QPS = 总请求数 / ( 进程总数 * 请求时间 )<br>QPS: 单个进程每秒请求服务器的成功次数<br>峰值QPS:<br>原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间<br>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p><h2 id="rpsrequests-per-second"><a class="markdownIt-Anchor" href="#rpsrequests-per-second"></a> RPS（Requests Per Second）</h2><p>每秒能处理的请求数目。等效于QPS</p><h2 id="dsldomain-specific-language"><a class="markdownIt-Anchor" href="#dsldomain-specific-language"></a> DSL（Domain Specific Language）</h2><p>即领域特定语言，或者直接翻译成“特定领域的语言”，再直接点，其实就是这个语言不通用，只能用于特定的某个领域，俗称“小语言”。因此DSL也是语言。</p><h2 id="faqfrequently-asked-questions"><a class="markdownIt-Anchor" href="#faqfrequently-asked-questions"></a> FAQ（Frequently Asked Questions）</h2><p>中文意思就是“经常问到的问题”，或者更通俗地叫做“常见问题解答”。FAQ是当前网络上提供在线帮助的主要手段，通过事先组织好一些可能的常问问答对，发布在网页上为用户提供咨询服务。</p><h2 id="dcldouble-check-lock"><a class="markdownIt-Anchor" href="#dcldouble-check-lock"></a> DCL（double check lock）</h2><p>双重检查锁定，已被广泛当做多线程环境下延迟初始化的一种高效手段。遗憾的是，在Java中，如果没有额外的同步，它并不可靠。</p><h2 id="raidredundant-array-of-independent-disks"><a class="markdownIt-Anchor" href="#raidredundant-array-of-independent-disks"></a> RAID（Redundant Array of Independent Disks）</h2><p>独立冗余磁盘阵列</p><p>Apache<br>英 [əˈpætʃi] 美 [ə’pætʃɪ]</p><p>Hadoop<br>[hædu:p] 哈杜噗，没有官方的发音，通常都读作[h∧du:p]</p><h2 id="soaservice-oriented-architecture"><a class="markdownIt-Anchor" href="#soaservice-oriented-architecture"></a> SOA（service-oriented architecture）</h2><p>面向服务的体系结构是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。Martin Fowler提出SOA歧义Service Oriented Ambiguity，认为&quot;什么是SOA&quot;是不可能回答，因为不同的人意味着不同的事情，SOA意味服务接口，意味流程整合，意味资源再利用，意味着管制。</p><h2 id="asoapp-store-optimization"><a class="markdownIt-Anchor" href="#asoapp-store-optimization"></a> ASO（App store Optimization）</h2><p>是“应用商店优化”的简称。就是提升你APP在各类APP应用商店/市场排行榜和搜索结果排名的过程。</p><h2 id="b2b商家到商家"><a class="markdownIt-Anchor" href="#b2b商家到商家"></a> B2B：商家到商家</h2><p>阿里巴巴</p><h2 id="b2c商家到用户"><a class="markdownIt-Anchor" href="#b2c商家到用户"></a> B2C：商家到用户</h2><p>京东</p><h2 id="c2c用户到用户"><a class="markdownIt-Anchor" href="#c2c用户到用户"></a> C2C：用户到用户</h2><p>淘宝</p><h2 id="b2b2c商家到商家到用户"><a class="markdownIt-Anchor" href="#b2b2c商家到商家到用户"></a> B2B2C：商家到商家到用户</h2><p>天猫</p><h2 id="o2o线上到线下"><a class="markdownIt-Anchor" href="#o2o线上到线下"></a> O2O：线上到线下</h2><p>百度外卖、美团、饿了么</p><h2 id="cms"><a class="markdownIt-Anchor" href="#cms"></a> CMS</h2><p>内容管理系统,实现菜单，链接，图片，导航栏等的可配置化系统。</p><h2 id="crm"><a class="markdownIt-Anchor" href="#crm"></a> CRM</h2><p>客户关系管理系统，一套为各种角色提供各种功能的系统。包括不同角色的权限等。这个系统主要是为了客户提供功能的系统。</p><h2 id="wms"><a class="markdownIt-Anchor" href="#wms"></a> WMS</h2><p>仓库管理系统<br>通过入库业务、出库业务、仓库调拨、库存调拨和虚仓管理等功能，对批次管理、物料对应、库存盘点、质检管理、虚仓管理和即时库存管理等功能综合运用的管理系统，有效控制并跟踪仓库业务的物流和成本管理全过程，实现或完善的企业仓储信息管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;devops&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#devops&quot;&gt;&lt;/a&gt; DevOps&lt;/h2&gt;
&lt;p&gt;Development和Operations的组合词&lt;/p&gt;
&lt;h2 id=&quot;paasplatform-as-a-ser
      
    
    </summary>
    
      <category term="English" scheme="https://bobit.github.io/categories/English/"/>
    
    
      <category term="英语" scheme="https://bobit.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="互联网" scheme="https://bobit.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>高并发高负载类网站中数据库的设计</title>
    <link href="https://bobit.github.io/posts/48156525.html"/>
    <id>https://bobit.github.io/posts/48156525.html</id>
    <published>2017-11-13T14:28:17.000Z</published>
    <updated>2018-12-21T12:56:51.686Z</updated>
    
    <content type="html"><![CDATA[<p>高并发高负载类网站中数据库的设计方法总结</p><h3 id="关注点之数据库"><a class="markdownIt-Anchor" href="#关注点之数据库"></a> 关注点之数据库</h3><p>首先是数据库,这是大多数应用所面临的首个SPOF。尤其是Web2.0的应用，数据库的响应是首先要解决的。<br>一般来说MySQL是最常用的，可能最初是一个mysql主机，当数据增加到100万以上，那么，MySQL的效能急剧下降。常用的优化措施是M-S（主-从）方式进行同步复制，将查询和操作和分别在不同的服务器上进行操作。我推荐的是M-M-Slaves方式，2个主Mysql，多个Slaves，需要注意的是，虽然有2个Master，但是同时只有1个是Active，我们可以在一定时候切换。之所以用2个M，是保证M不会又成为系统的SPOF。<br>Slaves可以进一步负载均衡，可以结合LVS,从而将select操作适当的平衡到不同的slaves上。<br>以上架构可以抗衡到一定量的负载，但是随着用户进一步增加，你的用户表数据超过1千万，这时那个M变成了SPOF。你不能任意扩充Slaves，否则复制同步的开销将直线上升，怎么办？我的方法是表分区，从业务层面上进行分区。最简单的，以用户数据为例。根据一定的切分方式，比如id，切分到不同的数据库集群去。</p><p>全局数据库用于meta数据的查询。缺点是每次查询，会增加一次，比如你要查一个用户nightsailer,你首先要到全局数据库群找到nightsailer对应的cluster id，然后再到指定的cluster找到nightsailer的实际数据。<br>每个cluster可以用m-m方式，或者m-m-slaves方式。这是一个可以扩展的结构，随着负载的增加，你可以简单的增加新的mysql cluster进去。</p><p>需要注意的是：<br>1、禁用全部auto_increment的字段<br>2、id需要采用通用的算法集中分配<br>3、要具有比较好的方法来监控mysql主机的负载和服务的运行状态。如果你有30台以上的mysql数据库在跑就明白我的意思了。<br>4、不要使用持久性链接（不要用pconnect）,相反，使用sqlrelay这种第三方的数据库链接池，或者干脆自己做，因为php4中mysql的链接池经常出问题。</p><h3 id="系统架构之html静态化"><a class="markdownIt-Anchor" href="#系统架构之html静态化"></a> 系统架构之HTML静态化</h3><p>其实大家都知道，效率最高、消耗最小的就是纯静态化 <a href="http://www.ablanxue.com/shtml/201207/776.shtml%E7%9A%84html%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E6%88%91%E4%BB%AC%E7%9A%84%E7%BD%91%E7%AB%99%E4%B8%8A%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%87%87%E7%94%A8%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%98%AF" target="_blank" rel="noopener">http://www.ablanxue.com/shtml/201207/776.shtml的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是</a> 最有效的方法。但是对于大量内容并且频繁更新的网站，我们无法全部手动去挨个实现，于是出现了我们常见的信息发布系统CMS，像我们常访问的各个门户站点 的新闻频道，甚至他们的其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限 管理、自动抓取等功能，对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。<br>　　<br>　　除了门户和信息发布类型的网站，对于交互性要求很高的社区类型网站来说，尽可能的静态化也是提高性能的必要手段，将社区内的帖子、文章进行实时的静态化，有更新的时候再重新静态化也是大量使用的策略，像Mop的大杂烩就是使用了这样的策略，网易社区等也是如此。<br>　　<br>　 　同时，html静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑使用html静态化来实现，比如论坛 中论坛的公用设置信息，这些信息目前的主流论坛都可以进行后台管理并且存储再数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以考虑将这 部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求高并发。<br>　　<br>网站HTML静态化解决方案<br>当一个Servlet资源请求到达WEB服务器之后我们会填充指定的JSP页面来响应请求:<br>HTTP请求—Web服务器—Servlet–业务逻辑处理–访问数据–填充JSP–响应请求<br>HTML静态化之后:<br>HTTP请求—Web服务器—Servlet–HTML–响应请求<br>静态访求如下</p><p>Servlet:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">​        throws ServletException, IOException &#123;</span><br><span class="line">​    if(request.getParameter(&quot;chapterId&quot;) != null)&#123;</span><br><span class="line">​        String chapterFileName = &quot;bookChapterRead_&quot;+request.getParameter(&quot;chapterId&quot;)+&quot;.html&quot;;</span><br><span class="line">​        String chapterFilePath = getServletContext().getRealPath(&quot;/&quot;) + chapterFileName;</span><br><span class="line">​        File chapterFile = new File(chapterFilePath);</span><br><span class="line">​        if(chapterFile.exists())&#123;response.sendRedirect(chapterFileName);return;&#125;//如果有这个文件就告诉浏览器转向 </span><br><span class="line">​        INovelChapterBiz novelChapterBiz = new NovelChapterBizImpl();</span><br><span class="line">​        NovelChapter novelChapter = novelChapterBiz.searchNovelChapterById(Integer.parseInt(request.getParameter(&quot;chapterId&quot;)));//章节信息 </span><br><span class="line">​        int lastPageId = novelChapterBiz.searchLastCHapterId(novelChapter.getNovelId().getId(), novelChapter.getId());</span><br><span class="line">​        int nextPageId = novelChapterBiz.searchNextChapterId(novelChapter.getNovelId().getId(), novelChapter.getId());</span><br><span class="line">​        request.setAttribute(&quot;novelChapter&quot;, novelChapter);</span><br><span class="line">​        request.setAttribute(&quot;lastPageId&quot;, lastPageId);</span><br><span class="line">​        request.setAttribute(&quot;nextPageId&quot;, nextPageId);</span><br><span class="line">​        new CreateStaticHTMLPage().createStaticHTMLPage(request, response, getServletContext(), </span><br><span class="line">​                chapterFileName, chapterFilePath, &quot;/bookRead.jsp&quot;);</span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成HTML静态页面的类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package com.jb.y2t034.thefifth.web.servlet;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.OutputStreamWriter;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import javax.servlet.RequestDispatcher;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletOutputStream;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletResponseWrapper;</span><br><span class="line">/**</span><br><span class="line">* 创建HTML静态页面</span><br><span class="line">* 功能：创建HTML静态页面</span><br><span class="line">* 时间：2009年1011日</span><br><span class="line">* 地点：home</span><br><span class="line">* @author mavk</span><br><span class="line">  *</span><br><span class="line">  */</span><br><span class="line">  public class CreateStaticHTMLPage &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 生成静态HTML页面的方法</span><br><span class="line">     * @param request 请求对象</span><br><span class="line">     * @param response 响应对象</span><br><span class="line">     * @param servletContext Servlet上下文</span><br><span class="line">     * @param fileName 文件名称</span><br><span class="line">     * @param fileFullPath 文件完整路径</span><br><span class="line">     * @param jspPath 需要生成静态文件的JSP路径(相对即可)</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws ServletException</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">      public void createStaticHTMLPage(HttpServletRequest request, HttpServletResponse response,ServletContext servletContext,String fileName,String fileFullPath,String jspPath) throws ServletException, IOException&#123;</span><br><span class="line">      </span><br><span class="line">        response.setContentType(&quot;text/html;charset=gb2312&quot;);//设置HTML结果流编码(即HTML文件编码) </span><br><span class="line">        RequestDispatcher rd = servletContext.getRequestDispatcher(jspPath);//得到JSP资源 </span><br><span class="line">        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();//用于从ServletOutputStream中接收资源 </span><br><span class="line">        final ServletOutputStream servletOuputStream = new ServletOutputStream()&#123;//用于从HttpServletResponse中接收资源 </span><br><span class="line">            public void write(byte[] b, int off,int len)&#123;</span><br><span class="line">                byteArrayOutputStream.write(b, off, len);</span><br><span class="line">            &#125;</span><br><span class="line">            public void write(int b)&#123;</span><br><span class="line">                byteArrayOutputStream.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        final PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(byteArrayOutputStream));//把转换字节流转换成字符流 </span><br><span class="line">        HttpServletResponse httpServletResponse = new HttpServletResponseWrapper(response)&#123;//用于从response获取结果流资源(重写了两个方法) </span><br><span class="line">            public ServletOutputStream getOutputStream()&#123;</span><br><span class="line">                return servletOuputStream;</span><br><span class="line">            &#125;</span><br><span class="line">            public PrintWriter getWriter()&#123;</span><br><span class="line">                return printWriter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        rd.include(request, httpServletResponse);//发送结果流 </span><br><span class="line">        printWriter.flush();//刷新缓冲区，把缓冲区的数据输出 </span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(fileFullPath);</span><br><span class="line">        byteArrayOutputStream.writeTo(fileOutputStream);//把byteArrayOuputStream中的资源全部写入到fileOuputStream中 </span><br><span class="line">        fileOutputStream.close();//关闭输出流，并释放相关资源 </span><br><span class="line">        response.sendRedirect(fileName);//发送指定文件流到客户端 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="关注点之缓存-负载均衡-存储"><a class="markdownIt-Anchor" href="#关注点之缓存-负载均衡-存储"></a> 关注点之缓存、负载均衡、存储</h3><p>缓存是另一个大问题，我一般用memcached来做缓存集群，一般来说部署10台左右就差不多（10g内存池）。需要注意一点，千万不能用使用<br>swap，最好关闭linux的swap。</p><p>负载均衡/加速<br>可能上面说缓存的时候，有人第一想的是页面静态化，所谓的静态html，我认为这是常识，不属于要点了。页面的静态化随之带来的是静态服务的<br>负载均衡和加速。我认为Lighttped+Squid是最好的方式了。<br>LVS &lt;-------&gt;lighttped====&gt;squid(s) ====lighttpd</p><p>上面是我经常用的。注意，我没有用apache，除非特定的需求，否则我不部署apache，因为我一般用php-fastcgi配合lighttpd,<br>性能比apache+mod_php要强很多。</p><p>squid的使用可以解决文件的同步等等问题，但是需要注意，你要很好的监控缓存的命中率，尽可能的提高的90%以上。<br>squid和lighttped也有很多的话题要讨论，这里不赘述。</p><p>存储<br>存储也是一个大问题，一种是小文件的存储，比如图片这类。另一种是大文件的存储，比如搜索引擎的索引，一般单文件都超过2g以上。<br>小文件的存储最简单的方法是结合lighttpd来进行分布。或者干脆使用Redhat的GFS，优点是应用透明，缺点是费用较高。我是指<br>你购买盘阵的问题。我的项目中，存储量是2-10Tb，我采用了分布式存储。这里要解决文件的复制和冗余。<br>这样每个文件有不同的冗余，这方面可以参考google的gfs的论文。<br>大文件的存储，可以参考nutch的方案，现在已经独立为hadoop子项目。(你可以google it)</p><p>其他：<br>此外，passport等也是考虑的，不过都属于比较简单的了。</p><h3 id="系统架构之图片服务器分离"><a class="markdownIt-Anchor" href="#系统架构之图片服务器分离"></a> 系统架构之图片服务器分离</h3><p>大家知道，对于Web 服务器来说，不管是Apache、IIS还是其他容器，图片是最消耗资源的，于是我们有必要将图片与页面进行分离，这是基本上大型网站都会采用的策略，他 们都有独立的图片服务器，甚至很多台图片服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片问题而崩溃，在应用 服务器和图片服务器上，可以进行不同的配置优化，比如apache在配置ContentType的时候可以尽量少支持，尽可能少的LoadModule， 保证更高的系统消耗和执行效率。</p><p>利用Apache实现图片服务器的分离<br>缘由：<br>起步阶段的应用，都可能部署在一台服务器上（费用上的原因）<br>第一个优先分离的，肯定是数据库和应用服务器。<br>第二个分离的，会是什么呢？各有各的考虑，我所在的项目组重点考虑的节约带宽，服务器性能再好，带宽再高，并发来了，也容易撑不住。因此，我这篇文章的重点在这里。这里重点是介绍实践，不一定符合所有情况，供看者参考吧，<br>环境介绍：<br>WEB应用服务器：4CPU双核2G, 内存4G<br>部署：Win2003/Apache Http Server 2.1/Tomcat6<br>数据库服务器：4CPU双核2G, 内存4G<br>部署：Win2003/MSSQL2000<br>步骤：<br>步骤一：增加2台配置为：2CPU双核2G，内存2G普通服务器，做资源服务器<br>部署：Tomcat6，跑了一个图片上传的简单应用，（记得指定web.xml的<distributable>），并指定域名为res1.***.com,res2.***.com，采用ajp协议<br>步骤二：修改Apache httpd.conf配置<br>原来应用的文件上传功能网址为：<br>1、/fileupload.html<br>2、/otherupload.html<br>在httpd.conf中增加如下配置</distributable></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt; </span><br><span class="line">  ServerAdmin webmaster@***.com </span><br><span class="line">  ProxyPass /fileupload.html balancer://rescluster/fileupload lbmethod=byrequests stickysession=JSESSIONID nofailover=Off timeout=5 maxattempts=3    </span><br><span class="line">  ProxyPass /otherupload.html balancer://rescluster/otherupload.html lbmethod=byrequests stickysession=JSESSIONID nofailover=Off timeout=5 maxattempts=3    </span><br><span class="line">  #&lt;!--负载均衡--&gt; </span><br><span class="line">  &lt;Proxy balancer://rescluster/&gt; </span><br><span class="line">​    BalancerMember ajp://res1.***.com:8009 smax=5 max=500 ttl=120 retry=300 loadfactor=100 route=tomcat1 </span><br><span class="line">​    BalancerMember ajp://res2.***.com:8009 smax=5 max=500 ttl=120 retry=300 loadfactor=100 route=tomcat2 </span><br><span class="line">  &lt;/Proxy&gt; </span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>步骤三，修改业务逻辑：<br>所有上传文件在数据库中均采用全url的方式保存，例如产品图片路径存成：<a href="http://res1" target="_blank" rel="noopener">http://res1</a>.***.com/upload/20090101/product120302005.jpg</p><p>现在，你可以高枕无忧了，带宽不够时，增加个几十台图片服务器，只需要稍微修改一下apache的配置文件，即可。</p><h3 id="系统架构之数据库集群和库表散列"><a class="markdownIt-Anchor" href="#系统架构之数据库集群和库表散列"></a> 系统架构之数据库集群和库表散列</h3><p>大型网站都有复杂的应用，这些应用必须使用数据库，那么在面对大量访问的时候，数据库的瓶颈很快就能显现出来，这时一台数据库将很快无法满足应用，于是我们需要使用数据库集群或者库表散列。<br>　　<br>　　在数据库集群方面，很多数据库都有自己的解决方案，Oracle、Sybase等都有很好的方案，常用的MySQL提供的Master/Slave也是类似的方案，您使用了什么样的DB，就参考相应的解决方案来实施即可。<br>　　<br>　 　上面提到的数据库集群由于在架构、成本、扩张性方面都会受到所采用DB类型的限制，于是我们需要从应用程序的角度来考虑改善系统架构，库表散列是常用并 且最有效的解决方案。我们在应用程序中安装业务和应用或者功能模块将数据库进行分离，不同的模块对应不同的数据库或者表，再按照一定的策略对某个页面或者 功能进行更小的数据库散列，比如用户表，按照用户ID进行表散列，这样就能够低成本的提升系统的性能并且有很好的扩展性。sohu的论坛就是采用了这样的 架构，将论坛的用户、设置、帖子等信息进行数据库分离，然后对帖子、用户按照板块和ID进行散列数据库和表，最终可以在配置文件中进行简单的配置便能让系 统随时增加一台低成本的数据库进来补充系统性能。</p><p>集群软件的分类：<br>一般来讲，集群软件根据侧重的方向和试图解决的问题，分为三大类：高性能集群（High performance cluster，HPC）、负载均衡集群（Load balance cluster， LBC），高可用性集群（High availability cluster，HAC）。<br>高性能集群（High performance cluster，HPC），它是利用一个集群中的多台机器共同完成同一件任务，使得完成任务的速度和可靠性都远远高于单机运行的效果。弥补了单机性能上的不足。该集群在天气预报、环境监控等数据量大，计算复杂的环境中应用比较多；<br>负载均衡集群（Load balance cluster， LBC），它是利用一个集群中的多台单机，完成许多并行的小的工作。一般情况下，如果一个应用使用的人多了，那么用户请求的响应时间就会增大，机器的性能也会受到影响，如果使用负载均衡集群，那么集群中任意一台机器都能响应用户的请求，这样集群就会在用户发出服务请求之后，选择当时负载最小，能够提供最好的服务的这台机器来接受请求并相应，这样就可用用集群来增加系统的可用性和稳定性。这类集群在网站中使用较多；<br>高可用性集群（High availability cluster，HAC），它是利用集群中系统 的冗余，当系统中某台机器发生损坏的时候，其他后备的机器可以迅速的接替它来启动服务，等待故障机的维修和返回。最大限度的保证集群中服务的可用性。这类系统一般在银行，电信服务这类对系统可靠性有高的要求的领域有着广泛的应用。<br>2 数据库集群的现状<br>数据库集群是将计算机集群技术引入到数据库中来实现的，尽管各厂商宣称自己的架构如何的完美，但是始终不能改变Oracle当先，大家追逐的事实，在集群的解决方案上Oracle RAC还是领先于包括微软在内的其它数据库厂商，它能满足客户高可用性、高性能、数据库负载均衡和方便扩展的需求。<br>Oracle’s Real Application Cluster (RAC)<br>Microsoft SQL Cluster Server (MSCS)<br>IBM’s DB2 UDB High Availability Cluster(UDB)<br>Sybase ASE High Availability Cluster (ASE)<br>MySQL High Availability Cluster (MySQL CS)<br>基于IO的第三方HA(高可用性)集群<br>当前主要的数据库集群技术有以上六大类，有数据库厂商自己开发的；也有第三方的集群公司开发的；还有数据库厂商与第三方集群公司合作开发的，各类集群实现的功能及架构也不尽相同。<br>RAC（Real Application Cluster，真正应用集群）是Oracle9i数据库中采用的一项新技术，也是Oracle数据库支持网格计算环境的核心技术。它的出现解决了传统数据库应用中面临的一个重要问题：高性能、高可伸缩性与低价格之间的矛盾。在很长一段时间里，甲骨文都以其实时应用集群技术(Real Application Cluster，RAC)统治着集群数据库市场</p><h3 id="系统架构之缓存"><a class="markdownIt-Anchor" href="#系统架构之缓存"></a> 系统架构之缓存</h3><p>缓存一词搞技术的都接触过，很多地方用到缓存。网站架构和网站开发中的缓存也是非常重要。这里先讲述最基本的两种缓存。高级和分布式的缓存在后面讲述。<br>架构方面的缓存，对Apache比较熟悉的人都能知道Apache提供了自己的缓存模块，也可以使用外加的Squid模块进行缓存，这两种方式均可以有效的提高Apache的访问响应能力。<br>网站程序开发方面的缓存，Linux上提供的Memory Cache是常用的缓存接口，可以在web开发中使用，比如用Java开发的时候就可以调用MemoryCache对一些数据进行缓存和通讯共享，一些大 型社区使用了这样的架构。另外，在使用web语言开发的时候，各种语言基本都有自己的缓存模块和方法，PHP有Pear的Cache模块，Java就更多了，.net不是很熟悉，相信也肯定有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高并发高负载类网站中数据库的设计方法总结&lt;/p&gt;
&lt;h3 id=&quot;关注点之数据库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关注点之数据库&quot;&gt;&lt;/a&gt; 关注点之数据库&lt;/h3&gt;
&lt;p&gt;首先是数据库,这是大多数应用所面临的首个SPOF。尤其是W
      
    
    </summary>
    
      <category term="并发编程" scheme="https://bobit.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="高并发" scheme="https://bobit.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高负载" scheme="https://bobit.github.io/tags/%E9%AB%98%E8%B4%9F%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统的开发注意事项</title>
    <link href="https://bobit.github.io/posts/396258dc.html"/>
    <id>https://bobit.github.io/posts/396258dc.html</id>
    <published>2017-11-13T14:27:17.000Z</published>
    <updated>2018-12-21T12:56:55.823Z</updated>
    
    <content type="html"><![CDATA[<p>对于高并发并没有什么通用解决方案,必须根据业务场景进行分析,不同的业务场景对于架构的取舍是不一样的.但万变不离其宗,掌握这些处理高并发的分析方法还是很有必要的.</p><h2 id="负载均衡"><a class="markdownIt-Anchor" href="#负载均衡"></a> 负载均衡</h2><p>任务服务器hibernate+tomcat+数据库<br>商用服务器经常因为一些商业的原因被很多为生活苦苦奋斗的hack们扫荡。对于一个要支持高并发的系统来说，在开发阶段有几个事情需要我们注意：</p><ol><li>如果你用hibernate，注意你的主键获取不要用increment了，那玩意在并发的时候给你带来主键约束错误，还是考虑使用sequence之类的主键策略吧</li><li>定时任务的考虑，并不是所有的定时任务都需要考虑并发的情况。但是例如定时些数据库的时候，如果你做负载均衡了，每个服务器都会写，是否造成重复写脏数据就需要看业务逻辑而定了。例如：你要定时给某个邮箱发送邮件，负载的时候，每个机器都会做相同的操作，定时任务会造成多个机器都发送邮件。（你可以考虑将某些定时任务移动到存储过程或者使用单独的定时服务器来做。）</li><li>使用二级缓存的时候注意，负载均衡的时候，你的二级缓存对数据的处理是否还符合业务逻辑？<br>常见的负载均衡：就是多个服务器执行相同的代码，我们通过tomcat将请求均衡的分布在某个服务器上。如果你使用increment策略，在开发组内多个成员在各自的开发机器上进行数据添加的时候，经常会出现主键约束错误</li><li>定时任务：有些定时任务在多台机器做负载均衡的时候不适合使用，你可以考虑将任务使用一个链接请求处理，然后在做一个单独的请求链接的项目，定时请求链接。这样做的好处是：即利用了系统的负载均衡，同时还利用了系统本身的业务逻辑。</li></ol><h2 id="业务逻辑"><a class="markdownIt-Anchor" href="#业务逻辑"></a> 业务逻辑</h2><p>在高并发的情况下如何找到业务繁忙的热点并进行优化,完全只能凭经验.<br>从处理技巧上,至少你可以知道处理高并发的业务逻辑是:<br>​    前端:异步请求+资源静态化+cdn<br>​    后端:请求队列+轮询分发+负载均衡+共享缓存<br>​    数据层:redis缓存+数据分表+写队列<br>​    存储:raid阵列+热备<br>​    网络:dns轮询+DDOS攻击防护</p><h2 id="多学习"><a class="markdownIt-Anchor" href="#多学习"></a> 多学习</h2><h3 id="如何学习高并发的工具"><a class="markdownIt-Anchor" href="#如何学习高并发的工具"></a> 如何学习高并发的工具?</h3><p>处理高并发的开源轮子其实很多.很多高并发的架构分享都会提及使用的工具,自己多留心,再看看手册,有条件自己搭起来跑一跑。redis,nginx/Tengine,keeplive,DRBD,heartbeat这些小工具还是可以在虚拟机上面多开几台跑起来的.至于大业务场景,除了进大公司没有别的办法,因为有些工具运行的配置要求太高,必须多台服务器配合才能完成.</p><h3 id="如何模拟高并发场景"><a class="markdownIt-Anchor" href="#如何模拟高并发场景"></a> 如何模拟高并发场景?</h3><p>并不是只有实际生产环境才能测试高并发,其实模拟高并发的轮子也很多,最常用的apache benchmark,winrunner,loadrunner,这些教程很多,用来模拟基本的高并发业务绰绰有余,自己安装试用版,学学如何用,模拟些常用的业务。如果有精力,业内很喜欢用perl,python,C来写一些针对热点业务的负载脚本.这需要有http协议等网络封包的理论基础.</p><h2 id="一些建议"><a class="markdownIt-Anchor" href="#一些建议"></a> 一些建议</h2><p>处理高并发要学习的东西实在太多.要在没有实际工作经验的情况下逐一了解太难,也很难深入.对于高并发的学习,我建议除了多阅读高并发架构的文档学习基本的方法论以外,自己要去深入学习网络基础,数据结构和算法.这些都是处理高并发热点的理论基础.</p><h2 id="高并发量网站解决方案"><a class="markdownIt-Anchor" href="#高并发量网站解决方案"></a> 高并发量网站解决方案</h2><h3 id="一个小型的网站"><a class="markdownIt-Anchor" href="#一个小型的网站"></a> 一个小型的网站</h3><p>可以使用最简单的html静态页面就实现了，配合一些图片达到美化效果，所有的页面均存放在一个目录下，这样的网站对系统架构、性能的要求都很简单。随着互联网业务的不断丰富，网站相关的技术经过这些年的发展，已经细分到很细的方方面面，尤其对于大型网站来说，所采用的技术更是涉及面非常 广，从硬件到软件、编程语言、数据库、WebServer、防火墙等各个领域都有了很高的要求，已经不是原来简单的html静态网站所能比拟的。</p><h3 id="大型网站"><a class="markdownIt-Anchor" href="#大型网站"></a> 大型网站</h3><p>比如门户网站，在面对大量用户访问、高并发请求方面，基本的解决方案集中在这样几个环节：使用高性能的服务器、高性能的数据库、高效率的编程语言、还有高性能的Web容器。这几个解决思路在一定程度上意味着更大的投入。</p><h4 id="html静态化"><a class="markdownIt-Anchor" href="#html静态化"></a> HTML静态化</h4><p>其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的网站上的页面采用静态页面来实现，这个最简单的方法其实也是 最有效的方法。但是对于大量内容并且频繁更新的网站，我们无法全部手动去挨个实现，于是出现了我们常见的信息发布系统CMS，像我们常访问的各个门户站点 的新闻频道，甚至他们的其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限 管理、自动抓取等功能，对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。<br>　　除了门户和信息发布类型的网站，对于交互性要求很高的社区类型网站来说，尽可能的静态化也是提高性能的必要手段，将社区内的帖子、文章进行实时的静态化、有更新的时候再重新静态化也是大量使用的策略，像Mop的大杂烩就是使用了这样的策略，网易社区等也是如此。<br>　 　同时，html静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑使用html静态化来实现。比如论坛 中论坛的公用设置信息，这些信息目前的主流论坛都可以进行后台管理并且存储在数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以考虑将这 部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。</p><h4 id="图片服务器分离"><a class="markdownIt-Anchor" href="#图片服务器分离"></a> 图片服务器分离</h4><p>大家知道，对于Web服务器来说，不管是Apache、IIS还是其他容器，图片是最消耗资源的，于是我们有必要将图片与页面进行分离，这是基本上大型 网站都会采用的策略，他们都有独立的、甚至很多台的图片服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片问题 而崩溃。<br>　　在应用服务器和图片服务器上，可以进行不同的配置优化，比如apache在配置ContentType的时候可以尽量少支持、尽可能少的LoadModule，保证更高的系统消耗和执行效率。</p><h4 id="数据库集群-库表散列"><a class="markdownIt-Anchor" href="#数据库集群-库表散列"></a> 数据库集群、库表散列</h4><p>大型网站都有复杂的应用，这些应用必须使用数据库，那么在面对大量访问的时候，数据库的瓶颈很快就能显现出来，这时一台数据库将很快无法满足应用，于是我们需要使用数据库集群或者库表散列。<br>　　在数据库集群方面，很多数据库都有自己的解决方案，Oracle、Sybase等都有很好的方案，常用的MySQL提供的Master/Slave也是类似的方案，您使用了什么样的DB，就参考相应的解决方案来实施即可。<br>　　上面提到的数据库集群由于在架构、成本、扩张性方面都会受到所采用DB类型的限制，于是我们需要从应用程序的角度来考虑改善系统架构，库表散列是常用并且最有效的解决方案。<br>　　我们在应用程序中安装业务和应用或者功能模块将数据库进行分离，不同的模块对应不同的数据库或者表，再按照一定的策略对某个页面或者功能进行更小的数据库散列，比如用户表，按照用户ID进行表散列，这样就能够低成本的提升系统的性能并且有很好的扩展性。<br>　　sohu的论坛就是采用了这样的架构，将论坛的用户、设置、帖子等信息进行数据库分离，然后对帖子、用户按照板块和ID进行散列数据库和表，最终可以在配置文件中进行简单的配置便能让系统随时增加一台低成本的数据库进来补充系统性能。</p><h4 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h4><p>缓存一词搞技术的都接触过，很多地方用到缓存。网站架构和网站开发中的缓存也是非常重要。这里先讲述最基本的两种缓存。高级和分布式的缓存在后面讲述。<br>　　架构方面的缓存，对Apache比较熟悉的人都能知道Apache提供了自己的缓存模块，也可以使用外加的Squid模块进行缓存，这两种方式均可以有效的提高Apache的访问响应能力。<br>　  网站程序开发方面的缓存，Linux上提供的Memory Cache是常用的缓存接口，可以在web开发中使用，比如用Java开发的时候就可以调用MemoryCache对一些数据进行缓存和通讯共享，一些大 型社区使用了这样的架构。另外，在使用web语言开发的时候，各种语言基本都有自己的缓存模块和方法，PHP有Pear的Cache模块，Java就更多 了，.net不是很熟悉，相信也肯定有。</p><h4 id="镜像"><a class="markdownIt-Anchor" href="#镜像"></a> 镜像</h4><p>镜像是大型网站常采用的提高性能和数据安全性的方式，镜像的技术可以解决不同网络接入商和地域带来的用户访问速度差异，比如ChinaNet和 EduNet之间的差异就促使了很多网站在教育网内搭建镜像站点，数据进行定时更新或者实时更新。在镜像的细节技术方面，这里不阐述太深，有很多专业的现 成的解决架构和产品可选。也有廉价的通过软件实现的思路，比如Linux上的rsync等工具。</p><h4 id="负载均衡-2"><a class="markdownIt-Anchor" href="#负载均衡-2"></a> 负载均衡</h4><p>负载均衡将是大型网站解决高负荷访问和大量并发请求采用的高端解决办法。<br>　　负载均衡技术发展了多年，有很多专业的服务提供商和产品可以选择，我个人接触过一些解决方法，其中有两个架构可以给大家做参考。<br>（1）、硬件四层交换<br>　　第四层交换使用第三层和第四层信息包的报头信息，根据应用区间识别业务流，将整个区间段的业务流分配到合适的应用服务器进行处理。<br>　 　第四层交换功能就像是虚IP，指向物理服务器。它传输的业务服从的协议多种多样，有HTTP、FTP、NFS、Telnet或其他协议。这些业务在物理 服务器基础上，需要复杂的载量平衡算法。在IP世界，业务类型由终端TCP或UDP端口地址来决定，在第四层交换中的应用区间则由源端和终端IP地址、 TCP和UDP端口共同决定。<br>　　在硬件四层交换产品领域，有一些知名的产品可以选择，比如Alteon、F5等，这些产品很昂贵，但是物有所值，能够提供非常优秀的性能和很灵活的管理能力。“Yahoo中国”当初接近2000台服务器，只使用了三、四台Alteon就搞定了。<br>(2)、软件四层交换<br>　　大家知道了硬件四层交换机的原理后，基于OSI模型来实现的软件四层交换也就应运而生，这样的解决方案实现的原理一致，不过性能稍差。但是满足一定量的压力还是游刃有余的，有人说软件实现方式其实更灵活，处理能力完全看你配置的熟悉能力。<br>　 　软件四层交换我们可以使用Linux上常用的LVS来解决，LVS就是Linux Virtual Server，他提供了基于心跳线heartbeat的实时灾难应对解决方案，提高系统的强壮性，同时可供了灵活的虚拟VIP配置和管理功能，可以同时满 足多种应用需求，这对于分布式的系统来说必不可少。<br>　　一个典型的使用负载均衡的策略就是，在软件或者硬件四层交换的基础上搭建squid集群，这种思路在很多大型网站包括搜索引擎上被采用，这样的架构低成本、高性能还有很强的扩张性，随时往架构里面增减节点都非常容易。<br>　　对于大型网站来说，前面提到的每个方法可能都会被同时使用到，这里介绍得比较浅显，具体实现过程中很多细节还需要大家慢慢熟悉和体会。有时一个很小的squid参数或者apache参数设置，对于系统性能的影响就会很大。</p><h4 id="cdn加速技术"><a class="markdownIt-Anchor" href="#cdn加速技术"></a> CDN加速技术</h4><h5 id="什么是cdn"><a class="markdownIt-Anchor" href="#什么是cdn"></a> 什么是CDN？</h5><p>CDN的全称是内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。<br>CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网 络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。</p><h5 id="cdn的实现"><a class="markdownIt-Anchor" href="#cdn的实现"></a> CDN的实现</h5><p>​分为三类：镜像、高速缓存、专线。<br>　　镜像站点（Mirror Site），是最常见的，它让内容直接发布，适用于静态和准动态的数据同步。但是购买和维护新服务器的费用较高，还必须在各个地区设置镜像服务器，配备专业技术人员进行管理与维护。对于大型网站来说，更新所用的带宽成本也大大提高了。<br>　 　高速缓存，成本较低，适用于静态内容。Internet的统计表明，超过80%的用户经常访问的是20%的网站的内容，在这个规律下，缓存服务器可以处 理大部分客户的静态请求，而原始的服务器只需处理约20%左右的非缓存请求和动态请求，于是大大加快了客户请求的响应时间，并降低了原始服务器的负载。<br>　　CDN服务一般会在全国范围内的关键节点上放置缓存服务器。<br>　　专线，让用户直接访问数据源，可以实现数据的动态同步。</p><h5 id="cdn的实例"><a class="markdownIt-Anchor" href="#cdn的实例"></a> CDN的实例</h5><p>举个例子来说，当某用户访问网站时，网站会利用全球负载均衡技术，将用户的访问指向到距离用户最近的正常工作的缓存服务器上，直接响应用户的请求。<br>　 　当用户访问已经使用了CDN服务的网站时，其解析过程与传统解析方式的最大区别就在于网站的授权域名服务器不是以传统的轮询方式来响应本地DNS的解析 请求，而是充分考虑用户发起请求的地点和当时网络的情况，来决定把用户的请求定向到离用户最近同时负载相对较轻的节点缓存服务器上。<br>　　通过用户定位算法和服务器健康检测算法综合后的数据，可以将用户的请求就近定向到分布在网络“边缘”的缓存服务器上，保证用户的访问能得到更及时可靠的响应。<br>　　由于大量的用户访问都由分布在网络边缘的CDN节点缓存服务器直接响应了，这就不仅提高了用户的访问质量，同时有效地降低了源服务器的负载压力。</p><h3 id="附某cdn服务商的服务说明"><a class="markdownIt-Anchor" href="#附某cdn服务商的服务说明"></a> 附：某CDN服务商的服务说明</h3><p>采用GCDN加速方式<br>　　采用了GCDN加速方式以后，系统会在浏览用户和您的服务器之间增加一台GCDN服务器。浏览用户访问您的服务器时，一般静态数据，如图片、多媒体资料等数据将直接从GCDN服务器读取，使得从主服务器上读取静态数据的交换量大大减少。<br>　为VIP型虚拟主机而特加的VPN高速压缩通道，使用高速压缩的电信&lt;<mark>&gt;网通、电信&lt;</mark>&gt;国际（HK）、网通&amp; lt;==&gt;国际（HK）等跨网专线通道，智能多线，自动获取最快路径，极速的动态实时并发响应速度，实现了网站的动态脚本实时同步，对动态网站有 一个更加明显的加速效果。<br>　　每个网络运营商（电信、网通、铁通、教育网）均有您服务器的GCDN服务器，无论浏览用户是来自何处，GCDN都能让您的服务器展现最快的速度！另外，我们将对您的数据进行实时备份，让您的数据更安全！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于高并发并没有什么通用解决方案,必须根据业务场景进行分析,不同的业务场景对于架构的取舍是不一样的.但万变不离其宗,掌握这些处理高并发的分析方法还是很有必要的.&lt;/p&gt;
&lt;h2 id=&quot;负载均衡&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#负载
      
    
    </summary>
    
      <category term="并发编程" scheme="https://bobit.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="高并发" scheme="https://bobit.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java日志框架总结</title>
    <link href="https://bobit.github.io/posts/18c040aa.html"/>
    <id>https://bobit.github.io/posts/18c040aa.html</id>
    <published>2017-11-13T14:26:17.000Z</published>
    <updated>2018-12-21T12:57:03.788Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名Java程序员，我们开发了很多Java应用程序，包括桌面应用、WEB应用以及移动应用。然而日志系统是一个成熟Java应用所必不可少的，在开发和调试阶段，日志可以帮助我们更好更快地定位bug；在运行维护阶段，日志系统又可以帮我们记录大部分的异常信息，从而帮助我们更好的完善系统。本文要来分享一些Java程序员最常用的Java日志框架组件。<br>1、Log4j – 最受欢迎的Java日志组件</p><p>Log4j是一款基于Java的开源日志组件，Log4j功能非常强大，我们可以将日志信息输出到控制台、文件、用户界面，也可以输出到操作系统的事件记录器和一些系统常驻进程。更值得一提的是，Log4j可以允许你非常便捷地自定义日志格式和日志等级，可以帮助开发人员全方位地掌控日志信息。</p><p>官方网站：<a href="http://logging.apache.org/log4j/2.x/" target="_blank" rel="noopener">http://logging.apache.org/log4j/2.x/</a></p><p>2、SLF4J – 基于API的Java日志框架</p><p>SLF4J提供了一个简单统一的日志记录接口，开发者在配置和部署时只需要实现这个接口即可实现日志功能。 Logging API实现既可以选择直接实现SLF4J接的loging APIs如： NLOG4J、SimpleLogger。也可以通过SLF4J提供的API实现来开发相应的适配器如Log4jLoggerAdapter、JDK14LoggerAdapter。</p><p>官方网站：<a href="http://www.slf4j.org/" target="_blank" rel="noopener">http://www.slf4j.org/</a><br>3、Commons Logging</p><p>Commons Logging的实现不依赖于具体的日志实现工具，仅仅提供一些日志操作的抽象接口，它对其他的日志工具做了封装，比如Log4J, Avalon LogKit, 和JDK 1.4等。<br>4、gclogviewer – Java日志查看工具</p><p>gclogviewer是一个支持jdk 6的gc log可视化工具，和gcviewer相比，gclogviewer支持根据gc log生成GC的趋势图，也支持生成调优建议所需的数据趋势图。</p><p>官方网站：<a href="http://code.google.com/p/gclogviewer/" target="_blank" rel="noopener">http://code.google.com/p/gclogviewer/</a><br>5、Flume – Apache日志服务器</p><p>之前介绍的都是一些日志记录工具，Flume则是一个日志分析系统，Flume是分布式的，它有一个非常灵活的架构，用来收集、聚合以及移动大量日志数据，并且提供可靠、容错的系统架构。</p><p>官方网站：<a href="http://flume.apache.org/" target="_blank" rel="noopener">http://flume.apache.org/</a><br>6、zLogFabric – 日志存储系统</p><p>zLogFabric 是一个集成的跨平台日志解决方案，通过消息系统收集各个应用的日志信息存储到一个集中式的系统中。模块化的设计使得服务器可对日志进行存储、转发、警报以及生成日志统计信息。</p><p>zLogFabric 可收集来自文件、syslog、log4j、log4net 以及 Windows 事件的数据。</p><p>官方网站：<a href="http://www.zlogfabric.com/" target="_blank" rel="noopener">http://www.zlogfabric.com/</a><br>7、logstash – Java日志管理工具</p><p>logstash是一款功能非常强大的日志管理工具，利用logstash，你可以对日志进行传输、处理、管理和检索，并且提供Web接口以便开发者统计和查询日志信息。</p><p>官方网站：<a href="http://www.logstash.net/" target="_blank" rel="noopener">http://www.logstash.net/</a></p><p>官方网站：<a href="http://commons.apache.org/proper/commons-logging/" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-logging/</a><br>8、Darks Logs</p><p>Darks Logs和log4j类似，也适用于Java、Android等项目，但是Darks Logs使用更加简单，而且对Android端做了非常大的改善。Darks Logs对Sqlite的日志保存增加了Appender。其旨在解决Android日志无法灵活控制日志等级、格式、保存或显示目标等常用操作等的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名Java程序员，我们开发了很多Java应用程序，包括桌面应用、WEB应用以及移动应用。然而日志系统是一个成熟Java应用所必不可少的，在开发和调试阶段，日志可以帮助我们更好更快地定位bug；在运行维护阶段，日志系统又可以帮我们记录大部分的异常信息，从而帮助我们更好的
      
    
    </summary>
    
      <category term="并发编程" scheme="https://bobit.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://bobit.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器镜像删除</title>
    <link href="https://bobit.github.io/posts/ce026f5a.html"/>
    <id>https://bobit.github.io/posts/ce026f5a.html</id>
    <published>2017-11-13T14:21:17.000Z</published>
    <updated>2018-12-21T12:57:25.836Z</updated>
    
    <content type="html"><![CDATA[<p>1.停止所有的container，这样才能够删除其中的images：<br>docker stop $(docker ps -a -q)</p><p>如果要删除所有container的话再加一个指令：<br>docker rm $(docker ps -a -q)</p><p>2.查看当前有些什么images<br>docker images</p><p>3.删除images，通过image的id来指定删除谁<br>docker rmi <image id=""></image></p><p>如果要删除untagged images，也就是那些id为<none>的image的话可以用<br>docker rmi $(docker images | grep “^<none>” | awk “{print $3}”)</none></none></p><p>要删除全部image的话<br>docker rmi $(docker images -q)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.停止所有的container，这样才能够删除其中的images：&lt;br&gt;
docker stop $(docker ps -a -q)&lt;/p&gt;
&lt;p&gt;如果要删除所有container的话再加一个指令：&lt;br&gt;
docker rm $(docker ps -a -q)&lt;/
      
    
    </summary>
    
      <category term="Docker" scheme="https://bobit.github.io/categories/Docker/"/>
    
    
      <category term="docker" scheme="https://bobit.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring5源码解析-Spring</title>
    <link href="https://bobit.github.io/posts/6a130ff3.html"/>
    <id>https://bobit.github.io/posts/6a130ff3.html</id>
    <published>2017-11-13T14:18:17.000Z</published>
    <updated>2018-12-27T15:12:19.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要阅读源码"><a class="markdownIt-Anchor" href="#为什么要阅读源码"></a> 为什么要阅读源码</h2><p>学习编程不是学习配置东西，需要多看看底层的知识，《Java编程思想》里有一句深刻的话，“编程语言是程序员的表达的方式，而架构是程序员对世界的认知”。</p><h2 id="怎么阅读源码"><a class="markdownIt-Anchor" href="#怎么阅读源码"></a> 怎么阅读源码</h2><p>Spring框架包含了非常多的功能，不能漫无目地阅读，可以针对性阅读部分源码。<br>针对性阅读如下部分：<br>Spring架构<br>Spring模块<br>Spring运用的设计模式</p><h2 id="spring框架"><a class="markdownIt-Anchor" href="#spring框架"></a> Spring框架</h2><p><img src="../../gitbooks/static/images/6a130ff3/7445574-6c604b7559a79729.webp" alt="img"></p><p>Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。<br>框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，<br>同时为 J2EE 应用程序开发提供集成的框架</p><p>Spring框架由如下7个模块构成，组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。</p><h2 id="spring模块功能"><a class="markdownIt-Anchor" href="#spring模块功能"></a> Spring模块功能</h2><h4 id="核心容器spring-core"><a class="markdownIt-Anchor" href="#核心容器spring-core"></a> 核心容器(Spring core)</h4><p>核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。BeanFactory使用依赖注入的方式提供给组件依赖。</p><h4 id="spring上下文spring-context"><a class="markdownIt-Anchor" href="#spring上下文spring-context"></a> Spring上下文(Spring context)</h4><p>Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</p><h4 id="spring面向切面编程spring-aop"><a class="markdownIt-Anchor" href="#spring面向切面编程spring-aop"></a> Spring面向切面编程(Spring AOP)</h4><p>通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p><h4 id="spring-dao模块"><a class="markdownIt-Anchor" href="#spring-dao模块"></a> Spring DAO模块</h4><p>DAO模式主要目的是将持久层相关问题与一般的的业务规则和工作流隔离开来。Spring 中的DAO提供一致的方式访问数据库，不管采用何种持久化技术，Spring都提供一直的编程模型。Spring还对不同的持久层技术提供一致的DAO方式的异常层次结构。</p><h4 id="spring-orm模块"><a class="markdownIt-Anchor" href="#spring-orm模块"></a> Spring ORM模块</h4><p>Spring 与所有的主要的ORM映射框架都集成的很好，包括Hibernate、JDO实现、TopLink和IBatis SQL Map等。Spring为所有的这些框架提供了模板之类的辅助类，达成了一致的编程风格。<br>Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</p><h4 id="spring-web模块"><a class="markdownIt-Anchor" href="#spring-web模块"></a> Spring Web模块</h4><p>Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。Web层使用Web层框架，可选的，可以是Spring自己的MVC框架，或者提供的Web框架，如Struts、Webwork、tapestry和jsf。<br>Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p><h4 id="spring-mvc框架spring-webmvc"><a class="markdownIt-Anchor" href="#spring-mvc框架spring-webmvc"></a> Spring MVC框架(Spring WebMVC)</h4><p>MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。Spring的MVC框架提供清晰的角色划分：控制器、验证器、命令对象、表单对象和模型对象、分发器、处理器映射和视图解析器。Spring支持多种视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</p><h2 id="spring运用的设计模式"><a class="markdownIt-Anchor" href="#spring运用的设计模式"></a> Spring运用的设计模式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要阅读源码&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为什么要阅读源码&quot;&gt;&lt;/a&gt; 为什么要阅读源码&lt;/h2&gt;
&lt;p&gt;学习编程不是学习配置东西，需要多看看底层的知识，《Java编程思想》里有一句深刻的话，“编程语言是程序员的表
      
    
    </summary>
    
      <category term="Source" scheme="https://bobit.github.io/categories/Source/"/>
    
    
      <category term="Spring" scheme="https://bobit.github.io/tags/Spring/"/>
    
      <category term="Spring5" scheme="https://bobit.github.io/tags/Spring5/"/>
    
  </entry>
  
  <entry>
    <title>互联网名词大全</title>
    <link href="https://bobit.github.io/posts/d6a87309.html"/>
    <id>https://bobit.github.io/posts/d6a87309.html</id>
    <published>2017-11-13T13:29:17.000Z</published>
    <updated>2018-12-21T13:10:40.872Z</updated>
    
    <content type="html"><![CDATA[<p>数据统计分析篇<br>PC 网站</p><p>Traffic<br>流量，在互联网领域内，统计网站使用量的笼统用语。</p><p>UV<br>Unique Vister，独立访客。</p><p>PV<br>Page View，即网站被浏览的总次数。</p><p>IP<br>即Internet Protocols，指独立 IP 数，一天内相同 IP 地址只被计算一次。</p><p>Impressions<br>展示数，也称接触人次，用户打开网页或者广告的每一次显示，就是一个 Impression；广告主希望 10 万人次看到广告，就是 10 万次 Impression；是评估广告效果的元素之一。</p><p>Click<br>（点击量/点击次数）即 Click through，用户点击广告的次数，评估广告效果的指标之一。</p><p>Click Rate</p><p>（点击率/点进率）即 Click through Rate;即网络广告被点击的次数与访问次数的比例，即 clicks/impressions.如果这个页面  被访问了 100 次，而页面上的广告也被点击了 20 次，那么 CTR 为 20%，CTR 是评估广告效果的指标之一。</p><p>人均访问页面<br>PV 总和除以 IP=人均访问页面。人均访问页面&gt;=10 个，才算优质用户。</p><p>页面停留时间<br>访客浏览单页面所花费的平均时长,页面的停留时长=进入下一个页面的时  间-进入本页面<br>的时间。</p><p>Reach<br>到达率，特定目标受众，在特定时期内有机会看到广告或广告活动的比例。也称为“覆盖  ”或“覆盖范围”。  跳出率：  跳出率是指浏览了一个页面就离开的用户占一组页面或一个页面访问次数的百分比。</p><p>二跳率<br>网站页面展开后，用户在页面上产生的首次点击被称为 “二跳”，二跳的次数即为”二跳量”，二跳量与浏览量的比值称为页面的二跳率。</p><p>CR</p><p>转化率，Conversion Rate 的缩写，是指访问某一网站访客中，转化的访客占全部访客的比例。</p><p>ROI</p><p>Return On Investment 的缩写，投资回报率。是指通过投资而应返回的价值，即企业从一项投资活动  中得到的经济回报。它涵盖了企业的获利目标。</p><p>电商</p><p>SKU<br>Stock Keeping Unit（库存量单位）。即库存进出计量的单位，可以是以件，盒，托盘等为单位。SKU 这是  对于大型连锁超市 DC（配送中心）物流管理的一个必要的方法。现在已经被引申为产品统  一编号的简称，每种产品均对应有唯一的 SKU 号。</p><p>客单价<br>是指每一个订单的平均购买商品金额，也就是平均交易金额。</p><p>GMV<br>Gross Merchandise Volume，是成交总额（一定时间段内）的意思。</p><p>动销率<br>商品动销率=动销品种数  ÷  门店经营总品种数*100%。</p><p>重复购买率<br>指消费者在网站中的重复购买次数。</p><p>APP</p><p>DAU<br>Daily Active User，日活跃用户数量。</p><p>MAU<br>Month Active User 月活跃用户量。</p><p>ARPU<br>(Average Revenue Per User)即每用户平均收入，用于衡量电信运营商和互联网公司业务收入的指标。</p><p>用户留存率<br>在互联网行业中，用户在某段时间内开始使用应用，经过一段时间后，仍然继续使用该应用的用户，被认作是留存用户。这部分用户占当时新增用户的比例即是留存率，会按照每隔 1 单位时间（例日、周、月）来进行统计。</p><p>商业模式篇<br>B2B（经济组织对经济组织）<br>是指企业对企业之间的营销关系，它将企业内部网，通过B2B网站与客户紧密结合起来，通过网络的快速反应，为客户提供更好的服务，从而促进企业的业务发展。</p><p>B2C（经济组织对消费者）<br>B2C 即企业通过互联网为消费者提供一个新型的购物环境—— 网上商店，消费者通过网络在网上购物、网上支付等消费行为。</p><p>B2B2C（企业对企业对消费者）<br>是一种电子商务类型的网络购物商业模式，B是BUSINESS的简称，C是CUSTOMER的简称，第一个B指的是商品或服务的供应商，第二个B指的是从事电子商务的企业，C则是表示消费者。</p><p>C2C（消费者对消费者）<br>就是个人与个人之间的电子商务。比如一个消费者有一台电脑，通过网络进行交易，把它出售给另外一个消费者，此种交易类型就称为 C2C 电子商务。</p><p>C2B（消费者集合竞价团购）<br>先有消费者需求产生而后有企业生产，即先有消费者提出需求，后有生产企业按需求组织生产。</p><p>F2C<br>指的是 Factory to customer，即从厂商直接到消费者个人的电子商务模式  O2O（网上与网下相结合）是指将线下的商务机会与互联网结合，让互联网成为线下交易的前台。</p><p>P2P（点对点、渠道对渠道）<br>是英文 peer-to peer 的缩写，意即个人对个人。又称点对点网络借款，是一种将小额资金聚集起来借贷给  有资金需求人群的一种民间小额借贷模式。  P2P 还有一种更广泛的概念，泛指互联网金融，借助互联网、移动互联网技术的网络信贷平  台及相关理财行为、金融服务。</p><p>众筹<br>是指用团购+预购的形式，向网友募集项目资金的模式。众筹利用互联网和 SNS 传播的特性，让小企业、艺术家或个人对公众展示他们的创意，争取大家的关注和支持，进而获得所需要的资金援助。</p><p>众包<br>众包指的是一个公司或机构把过去由员工执行的工作任务，以自由自愿的形式外包给非特定的（而且通常是大型的）大众网络的做法。众包的任务通常是由个人来承担，但如果涉及到需要多人协作完成的任务，也有可能以依靠开源的个体生产的形式出现。</p><p>孵化器<br>一般指企业孵化器，在中国也称高新技术创业服务中心，它通过为新创办的科技型中小企业提供物理空间和基础设施，提供一系列的服务支持，进而降低创业者的创业风  险和创业成本，提高创业成功率，促进科技成果转化，培养成功的企业和企业家。</p><p>SaaS（软件服务）<br>是 Software-as-aService（软件即服务）的简称。它是一种通过 Internet 提供软件的模式，厂商将应用软件  统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的  应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提  供的服务。</p><p>CRM<br>现代信息技术、经营思想的结合体，它以信息技术为手段，通过对以“客户为中心”  的业务流程的重要组合和设计，形成一个自动化的解决方案，以提高客户的忠诚度，最终实现业务操作效益的提高和利润的增长。</p><p>SoLoMo（社交+本地化+移动）<br>这个词形容三种概念混合的产物，即：Social（社交的）、Local（本地的）、Mobile（移动的），连起来就是 SoLoMo（索罗门），社交本地移动，即社交加本地化加移动，它代表着未来互联网发展的趋势。</p><p>LBS<br>基于位置的服务，它是通过电信移动运营商的无线电通讯网络（如 GSM 网、CDMA 网）或外部定位方式(如 GPS)获取移动终端用户的位置信息（地理坐标，或大地坐标），在地理信息系统（外语缩写：GIS、外语全称：Geographic Information System）平台的支持下，为用户提供相应服务的一种增值业务。</p><p>SNS<br>Social Networking Services，即社会性网络服务，是指个人之间的关系网络,这种基于社会网络关  系系统思想的网站就是社会性网络网站(SNS 网站)。现在许多 WEB2.0 网站都属于SNS 网站，  如网络聊天（IM）、交友、视频分享、博客、播客、网络社区、音乐共享等。社会性网络  的理论基础源于六度理论（六度分隔理论，Six Degrees of Separation）和150 法则（Rule Of 150）。另外不仅现在一些大公司网站开始了一些 SNS 应用，一些垂直领域的行业站点也开  始了 SNS 的尝试。目前国外较出名的是 facebook、myspac，国内流行的 SNS 有海内、校内、  开心、51 等。</p><p>OTT<br>“Over The Top”的缩写，是指通过互联网向用户提供各种应用服务。这种应用和目前运营商所提供的  通信业务不同，它仅利用运营商的网络，而服务由运营商之外的第三方提供。目前，典型的OTT业务有互联网电视业务，苹果应用商店等。</p><p>OTA<br>旅游电子商务行业的专业词语。代表为号码百事通、旅游百事通、驴妈妈旅游网、携程网、出游客旅游网、乐途旅游网、欣欣旅游网、芒果网、艺龙网、同程网、搜旅网、途  牛旅游网和易游天下、快乐 e 行旅行网等。OTA 的出现将原来传统的旅行社销售模式放到网络平台上，更广泛的传递了线路信息，互动式的交流更方便了客人的咨询和订购。</p><p>电子商务<br>以信息网络技术为手段，以商品交换为中心的商务活动。在因特网开放的网络  环境下，基于浏览器/服务器应用方式，买卖双方不谋面地进行各种商贸活动，实现消费者的网上购物、商户之间的网上交易和在线电子支付以及各种商务活动、交易活动、金融活  动和相关的综合服务活动的一种新型的商业运营模式。电子商务分为：ABC、B2B、B2C、C2 C、B2M、M2C、B2A(即 B2G)、C2A(即 C2G)、O2O 等。</p><p>海淘<br>通过互联网检索海外商品信息，并通过电子订购单发出购物请求，然后填上私人信用卡号码，由海外购物网站通过国际快递发货，或是由转运公司代收货物再转寄回国。海淘，一般付款方式是款到发货(在线信用卡付款、PayPal 账户付款)。</p><p>Rebate Site  返利站<br>返利站采用购物返现金的形式聚集大量网络购物会员，会员从这里去淘宝网和各大网上商城购物，订单完成后(无退货)，返利站作为该商城的合作伙伴，可从该商城得到一定比例的销售佣金，返利站再把佣金的50%——  100%的返还给会员，返利站还推出团购返利，涵盖几十家知名团购网站，团购后再返利！  这就是现金返利的来源，一点也不影响会员本来能享受到的任何优惠活动。</p><p>POP<br>为向网站以外的用户提供服务的开放平台，例如京东、苏宁、亚马逊都推出开放平台业务。未来电商在这块的竞争也日趋激烈。</p><p>微商<br>基于微信生态的社会化分销模式，是企业或者个人基于社会化媒体开店的新型电商  ，从模式上来说主要分为两种：基于微信公众号的微商成为 B2C 微商，基于朋友圈开店的成  为C2C 微商。微商和淘宝一样，有天猫平台(B2C 微商)也有淘宝集市(C2C 微商)。所不同的是 微商基于微信“连接一切”的能力，实现商品的社交分享、熟人推荐与朋友圈展示。从微商来流程来说，微商主要由基础完善的交易平台微盟旺铺、营销插件、分销体系以及个人端分享推广微客四个流程部分组成。</p><p>微店<br>全球第一个云销售电子商务，是零成本开设的巨型商城，是计算机云技术和传统电子商务相结合的创新模式。微店并不是利用手机开网店，这个“微”是指无须资金、无须成本、无须处理货源，无须处理物流和客服，就可以赚取推广佣金。微店的模式之所以受到追捧，是因为它颠覆了传统网商既要找货源，又要做推广的高门槛要求，很好地解决了货源与推广的分工问题。这是互联网分工进一步细化的体现。</p><p>UGC<br>互联网术语，全称为 User  Generated  Content，也就是用户生成内容的意思。UGC 的概念最早起源于互联网领域，即用户将自己  原创的内容通过互联网平台进行展示或者提供给其他用户。UGC 是伴随着以提倡个性化为主  要特点的 Web2.0 概念兴起的。</p><p>PGC<br>全称：Professional Generated Content），互联网术语。指专业生产内容（视频网站）、专家生产内容（微博）。用来泛  指内容个性化、视角多元化、传播民主化、社会关系虚拟化。</p><p>OEM</p><p>也称为定点生产，俗称代工（生产），基本含义为品牌生产者不直接生产产品，而是 利用自己掌握的关键的核心技术负责设计和开发新产品，控制销售渠道，具体的加工任务 通过合同订购的方式委托同类产品的其他厂家生产。之后将所订产品低价买断，并直接贴上自己的品牌商标。</p><p>ODM<br>某“原始设计制造商”设计出某产品后，在某些情况下可能会被另外一些企业看中，  要求配上后者的品牌名称来进行生产，或者稍微修改一下设计来生产。这样可以使其他厂商减少自己研制的时间。承接设计制造业务的制造商被称为 ODM 厂商，其生产出来的产品就是 ODM 产品。</p><p>鼠标+水泥（Clicks and Mortar）<br>又称为“砖块+鼠标”（Bricks and Clicks），是指传统商业模式（主要运用直接的面对面的方式与顾客发生联系）与互联网商业模式（主要通过网站、电子邮件、FTP 以及其他互联网技术手段与顾客发生联系）的联姻。它是一种将先进的互联网技术与传统优势资源相结合，利用先进的信息技术提高传统  业务的效率和竞争力，实现真正的商业利润的电子商务运作模式。鼠标+水泥是一个传统企  业电子化和互联网公司实体化的趋同过程，是电子商务发展的趋同方向。</p><p>“互联网+”<br>互联网+”是创新 2.0 下的互联网发展新形态、新业态，即充分发挥互联网在  生产要素配置中的优化和集成作用，将互联网的创新成果深度融合于经济社会各领域之中，提高实体经济的创新力和生产力，形成更广泛的以互联网为基础设施和实现工具的经济发展新形态。“互联网+”，是知识社会创新 2.0 推动下的互联网形态演进。新一代信息技术发展催生了创新 2.0，而创新 2.0 又反过来作用与新一代信息技术形态的形成与发展，重塑了物联网、云计算、社会计算、大数据等新一代信息技术的新形态，并进一步推动知识社会以用户创新、开放创新、大众创新、协同创新为特点的创新 2.0，改变了我们的生产、  工作、生活方式，也引领了创新驱动发展的“新常态”。</p><p>物联网<br>把所有物品通过信息传感设备与互联网连接起来，进行信息交换，即“物物相息”，以实现智能化识别和管理。</p><p>网络媒体、广告、营销篇<br>网络媒体</p><p>Portal    门户网站<br>是指通向某类综合性互联网信息资源并提供有关信息服务的应用系统。门户网站最初提供搜索服务、目录服务，后来由于市场竞争日益激烈，门户网站不得不快速地拓展各种新的业务类型，希望通过门类众多的业务来吸引和留住互联网用户，以至于目前门户网站的业务包罗万象，成为网络世界的“百货商场”或“网络超市”。在中国，综合门户网站包含  新浪，网易，搜狐，腾迅。</p><p>vertical portal  垂直门户<br>是相对新浪这样的传统门户网站而言，  传统门户网站的内容广泛而全面，覆盖各行各业，“垂直门户”则专注于某一领域（或地  域）如 IT、娱乐、体育、汽车，力求成为关心某一领域（或地域）内容的人上网的第一站  。</p><p>Dictionary    网址导航站<br>网址导航就是一个集合较多网址，并按照一定条件进行分类的一种网址站。网址导航方便网友们快速找到自己需要的网站，而不用去记住各类网站的网址，就可以直接进到所需的网站。现在的网址导航一般还自身提供常用查询工具，以及邮箱登陆、搜索引擎入口，有的还有热点新闻等功能。网址导航从诞生的那一刻起，就凭借其简单的模式和便利的服务  以及好的用户体验深得民心，不过也注定其发展与竞争都将成为互联网网站中竞争最激烈的类别，发展至今，更是成为互联网大佬们最大的竞争对象。</p><p>Search Engine    搜索引擎<br>可被搜索的网站及其内容数据库。搜索引擎一般通过搜索用户指定的关键词来帮助用户找 到他们所需要的信息。搜索引擎会提供一个网页的索引，供用户输入关键词或相关内容来 查询信息。创建索引时可以使用专门的资源列表，或者使用称为“机器人”的程序来自动  访问站点和网页 HTML 代码中的索引文本。</p><p>Social Media    社交媒体<br>也称为社会化媒体、社会性媒体，指允许人们撰写、分享、评价、讨论、相互沟通的网站和技术。所谓社交媒体应该是大批网民自发贡献，提取，创造新闻咨询，然后传播的过程  。</p><p>Streaming Media    数据流媒体<br>一种以稳定、持续的数据流来传输的技术。随着互联网的发展，数据流媒体已变得越来越重要。大多数用户无法足够快速地下载大型多媒体文件，利用数据流，用户在该文件完成下载之前即可开始在网上观赏或收听。</p><p>自媒体(外文名：We Media)<br>又称“公民媒体”或“个人媒体”，是指私人化、平民化、普泛化、自主化的传播  者,以现代化、电子化的手段，向不特定的大多数或者特定的单个人传递规范性及非规范性  信息的新媒体的总称。自媒体平台包括:博客、微博、微信、百度官方贴吧、论坛/BBS 等网络社区。</p><p>TMT  数字新媒体<br>或叫 TMT（Technology，Media，Telecom）产业。TMT 是电信、媒体和科  技三个英文单词的缩写的第一个字头，整合在一起，实际是未来电信、媒体科技(互联网)  ，包括信息技术这样一个融合趋势所产生的大的背景，这就是 TMT 产业。</p><p>网络广告</p><p>Ad Network  在线广告网络<br>Ad Network 即“广告网络”。在广告业内，这是一个较为广泛的概念。是一种介于想出售广告  流量资源的网站与想在网站上刊登广告的广告主之间的平台。</p><p>Ad Server  广告管理系统<br>指为媒体提供的一套综合性广告发布系统，可以帮助媒体管理、优化其广告流量，简化广告管理及投放流程，提供全面的广告投放报告，制定高效的投放解决方案，提升广告价值。Display AD 展示广告网站广告的主要形式，通常在文本的基础上再加上图像型信息，其形式如企业标识、相关产品图片，企业所在位置的简易电子地图或其他相关信息。</p><p>品牌广告<br>以树立产品品牌形象，提高品牌的市场占有率为直接目的，突出传播品牌在消费者心目中确定的位置的一种方法。</p><p>效果广告<br>基于效果为基础的广告系统中，广告主只需要为可衡量的结果付费。</p><p>Banner  横幅广告<br>一种常见的网络广告形式，常表现为 GIF、JPG 等格式建立的图像文件，定位在网页中，大多用来表现广告内容，同时还可实用 Java 等语言使其产生交互性，用 Shockwave 等插件工具增强表现力。</p><p>Buttons  按钮<br>网站上一小块形似按钮的可点击区域，往往采用动画形式，并连接到广告主的网站。</p><p>Pop-up Ad  弹出式广告<br>在用户浏览网页或打开新网页时弹出的短暂的广告。在已经显示内容的页面上出现的具有独立广告内容的窗口，一般是网页内容下载完成弹出式广告也随之出现，因而对浏览网页内容产生直接影响。</p><p>Skyscraper  擎天柱广告<br>一种又高又窄的网络广告格式，通常位于网页左右两侧的狭窄空间。</p><p>Rich Media (富媒体)<br>这种应用采取了所有适合的最先进技术，以最好的传达广告主的信息，  甚至与用户进行互动，如视频、flash 广告等。</p><p>Keyword  关键字广告<br>用户输入到搜索引擎中用于搜索匹配和相关结果的单词或词语。</p><p>竞价排名<br>一种按效果付费的网络推广方式。基本特点是按点击付费，推广信息出现在搜索结果中（一般是靠前的位置），如果没有被用户点击，则不收取推广费。竞价就是拍卖  ，关键词出价是影响排名的一个重要因素。</p><p>AdWords<br>Google 的关键词竞价广告。</p><p>Adsens<br>Google AdSense  是一种获取收入的快速简便的方法，适合于各种规模的网站发布商。它可以在网站的内容  网页上展示相关性较高的  Google 广告，并且这些广告不会过分夸张醒目。</p><p>百度凤巢<br>百度的关键词竞价广告。</p><p>淘宝直通车<br>淘宝的关键词竞价广告。</p><p>钻石展位<br>是淘宝网图片类广告位竞价投放平台，是为淘宝卖家提供的一种营销工具。钻石展位依靠图片创意吸引买家点击，获取巨大流量。</p><p>积分墙广告<br>在一个应用内展示各种积分任务（下载安装推荐的优质应用、注册、填表等  ），以供用户完成任务获得积分的页面。是除“广告条”、“插屏广告”外，第三方移动广告平台提供给应用开发者的另一新型移动广告盈利模式。</p><p>Ad Exchange  广告交易平台<br>Ad Exchange 是针对每次广告展示，以受众为单位进行实时竞价的互联网流量交换市场。能帮助广告联盟、代理机构和第三方技术提供商通过实时竞价的方式购买众多互联网站点的广告资源。</p><p>DSP    （Demand-Side Platform）<br>需求方平台  DSP 需求方平台是一个综合性管理平台，在这个平台上，广告主可以通过同一个界面管理多  个数字广告和数据交换的账户。利用 DSP，广告主可以在广告交易平台（Ad Exchange）对在线广告进行实时竞价（RTB Real-Time Bidding），高效管理广告定价，利用 DSP 也可以根据目标受众数据分析进行理性定价，就  像付费搜索的操作原理一样，在用户优化的基础上使用 DSP 设置如 CPC 和 CPA 这些关键性能指  标，从而达到理性定价的目<br>标。</p><p>DMP    （Data-Management Platform）<br>数据管理平台  DMP 数据管理平台，是把分散的第一、第三方数据进行整合纳入统一的技术平台，并对这些数据进行标准化和细分，让用户可以把这些细分结果推向现有的互动营销环境里。</p><p>RTB    （Real-Time Bidding）<br>实时竞价  RTB 实时竞价，是一种利用第三方技术在数以百万计的网站上针对每一个用户展示行为进行  评估以及出价的竞价技术。与大量购买投放频次不同，实时竞价规避了无效的受众到达，  只针对有意义的用户进行购买。它的核心是 DSP 平台（需求方平台）。  RTB 对于媒体来说，可以带来更多的广告销量、实现销售过程自动化及减低各项费用的支出  。而对于广告商和代理公司来说，最直接的好处就是提高了效果与投资回报率。</p><p>Media Plan  媒介计划<br>包含了传播目标，同时描述如何通过广告途径来实现这些目标的概述。它由媒介策划人员提供。媒介计划一般包括市场营销、广告投放以及媒介目标，相关的媒介策略通常在其基础上制定。</p><p>Campaign  广告活动<br>广告活动指在某一特定市场上为实现某一重大目标所集中进行的大规模的广告活动，是广<br>告决战思想的一种体现，是企业之间进行市场竞争的策略之一。</p><p>Landing Page  登陆页面<br>当用户点击了广告之后所访问的广告主网页。通常登陆页面会要求用户注册以便获得服务或购买产品，也称为点进 URL 或目标 URL。</p><p>Positioning    定位<br>投放广告的位置，可以指定广告出现的位置。</p><p>Targeted  针对性广告<br>通过分析人口特征、网络行为、消费习惯等制定的面向特定受众市场的广告  。</p><p>植入式广告<br>在电影或电视剧或者其它场景插入相关的广告。如变形金刚，非诚勿扰等。eCPM（effective cost per mille）指的就是每一千次展示可以获得的广告收入，展示的单位可以是网页，广告单元，  甚至是单个广告（在  AdSense  “高级报告”的“数据展示依据”下拉框中可以选择）。默认情况下，eCPM  指的都是千次网页展示（Pageview）收入。eCPM  只是用来反映网站盈利能力的参数，不代表收入。</p><p>CPD  （Cost Per Day）<br>每日成本，是按天收费的一种模式，是广告合作的一种常见方式。</p><p>CPM  （Cost Per Mille    或者 Cost Per Thousand; Cost Per Impressions）<br>千人成本，指由某一媒介或媒介广告排期表所送达 1000 人所需的成本。其原始英文为 Cost Per Mille，简称 CPM。其计算公式为：千人成本=（广告费用/到达人数）×1000。目前，CPM已经作为&quot;按广告每千次被展现收费&quot;的广告模式,成为网络广告的基本术语。</p><p>CPC  （Cost Per Click; Cost Per Thousand Click-Through  ）<br>点击成本，以每点击一次计费。在这种模式下广告主仅为用户点击广告的行为付费，而不再为广告的显示次数付费。</p><p>CPA  （Cost Per Action）<br>行动成本，每次行动的费用。即根据每个访问者对网络广告所采取的行动收费的定价模式，对于用户行为的定义，包括形成一次交易、获得一个注册用户、或者对网络广告的一次点击等。</p><p>CPE    （Cost Per Engagement）<br>每参与成本，旨在评估用户与品牌之间参与程度的价值。多应用于社交媒体，例如链接点击、喜欢、转发和“@回复”等等。另外 CPE 也指用户浏览过广告后，在一定时间内（如一周）与品牌进行的互动。</p><p>CPS    (Cost Per Sales =CPP Cost Per Purchase)<br>每购买成本，以实际销售产品数量来换算广告投放金额。广告主为规避风险，只有在用户点击广告并进行在线交易后，才支付广告费用。</p><p>网络营销推广</p><p>网络营销<br>以现代营销理论为基础，借助网络、通信和数字媒体技术实现营销目标的商务活动。企业网络营销包含企业网络推广和电子商务两大要素，网络推广就是利用互联网进行宣传推广活动，电子商务指的是利用简单、快捷、低成本的电子通讯方式，买卖双方无需谋面地进行各种商贸活动。</p><p>网络推广<br>通过互联网把产品或服务推广出去，使产品或服务增加曝光率，尽可能让更多的人知道。常见网络推广渠道有分类信息、问答、博客、论坛、视频网站等。</p><p>SEM<br>是“Search Engine Marketing”的缩写，意为“搜索引擎营销”。包含关键字广告和 SEO两大主要手段。</p><p>SEO<br>搜索引擎优化。搜索引擎优化（Search Engine Optimization，简称“SEO”），泛指为了提升网站在搜索引擎中的表现而采取的各种符合  必要的规则的手段和由此开展的各种工作。</p><p>EDM<br>内部邮件群发，第三方平台，数据库整合营销等方式，数据库营销。</p><p>社会化媒体营销<br>基于微博、微信、QQ、sns、bbs、博客等社交媒体来进行推销并创造业务机会和销售的行为。其最大的优势在于能够帮助企业推销，从而增加流量并建立新的业务合作关系。</p><p>口碑营销<br>企业在调查市场需求的情况下，为消费者提供需要的产品和服务，同时制定一定的口碑推广计划，让消费者自动传播公司产品和服务的良好评价，从而让人们通过口碑  了解产品、树立品牌、加强市场认知度，最终达到企业销售产品和提供服务的目的。</p><p>病毒式营销<br>是指通过用户的社会人际网络，使信息像病毒一样传播和扩散，利用快速复制  的方式传向数以千计、数以百万计的受众。也就是说，通过提供有价值的产品或服务，“ 让大家告诉大家”，通过别人为你宣传，实现“营销杠杆”的作用。</p><p>SMO<br>（社交媒体优化）通过社会化媒体、在线组织及社区网站获得公共传播的一整套方法。SMO的方法包括添加 RSS 订阅、顶上去、博客写作及非合作形式的第三方社区功能（如：Flickr图片幻灯片、YouTube 的视频分享）。</p><p>ASO<br>(App Store Optimization)就是提升你 APP 在各类 APP 电子市场排行榜和搜索结果排名的过程。类似移动  APP 的 SEO 优化。</p><p>饥饿营销<br>商品提供者有意调低产量，以期达到调控供求关系、制造供不应求“假象”、  维持商品较高售价和利润率，也达到维护品牌形象、提高产品附加值的目的。“饥饿营销  ”是把双刃剑，苹果公司的“可控泄漏”战略为其赢得了全球市场，而小米手机却也因过  分的“饥饿”让用户失去了耐心。</p><p>Interactive Marketing<br>互动营销通过互动营销能够向潜在客户进行推销并记住他们的行为和话语，从而使潜在客户知道广告主已了解其之前提供的信息。</p><p>SEO 相关<br>Meta<br>关键词密度<br>面包屑导航<br>内链<br>外链<br>反向链接<br>友情链接<br>锚文本<br>Home Page</p><p>主页<br>网站的第一张网页，是导航的起点。访问者可通过主页链接到站点内的其他页面。</p><p>SERP 搜索结果页面<br>SPAM<br>互联网上到处散布垃圾广告消息的现象。在搜索引擎上的 Spam 通常也称为作弊。搜索引擎营销中所说的 SPAM 是专门针对那些欺骗搜索引擎的信息。搜索引擎垃圾技术是利用不道德的技巧去提高自己搜索引擎上的排名。不诚实的网站管理员就是利用这样的手段去欺骗搜索引擎从而获得较高的排名。</p><p>PageRank    PR 值<br>PR 值是网页的级别技术。取自 Google 的创始人 Larry Page，它是 Google 排名运算法则(排名公式)的一部分，用来标识网页的等级/重要性。级别  从 1 到 10 级，10 级为满分。PR值越高说明该网页越受欢迎(越重要)。</p><p>Alexa<br><a href="http://Alexa.com" target="_blank" rel="noopener">Alexa.com</a> 是专门发布网站世界排名的网站，网站排名有两种：综合排名和分类排名。</p><p>沙盒<br>Google  反击垃圾网站的重要措施，出现在  2004  年，也就是举世瞩目的 Google  佛罗里达风暴和奥斯丁风暴之后的半年。有了沙盒，Google  仍然象过去一样迅速收录网站，从互联网上从新的网站里努力获取新鲜的信息，但是不再  象以前那样信任这些新网站。所有收录的网站都要经过“适用期”或者 “观察期”。经过时间的考验，如果这些网站能顺利通过  Google  多次的反“泛滥”过滤器(spam filter)的考验，最终这些网站就被放回搜索的“大海”之中，参与正常的排名竞赛之中。  这个过程少则两、三个月，长则要一年。新网站可以采取一些积极  的措施，争取早日走出沙盒。</p><p>技术及其他篇<br>技术</p><p>域名<br>由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。一个域名的目的是便于记忆和沟通的一组服务器的地  址（网站，电子邮件，FTP 等）。</p><p>服务器<br>是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。服务器的构成包括处理器、硬盘、内存  、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。在网络环境下，  根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，WEB  服务器等。</p><p>虚拟主机<br>在网络服务器上分出一定的磁盘空间供用户放置站点、应用组件等，提供必要的站点功能、数据存放和传输功能。也叫“网站空间”，就是把一台运行在互联网上的服  务器划分成多个“虚拟”的服务器，每一个虚拟主机都具有独立的域名和完整的 Internet  服务器（支持WWW、FTP、E-mail 等）功能。</p><p>DNS<br>（Domain Name System，域名系统），因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使  用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。通过主机名，最  终得到该主机名对应的 IP 地址的过程叫做域名解析（或主机名解析）。</p><p>VPN</p><p>（Virtual Private Network）VPN 网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p><p>FTP<br>文件传输协议。是一个用于在两台装有不同操作系统的机器中传输计算机文件的软件标准。它属于网络协议组的应用层。</p><p>SSL<br>“Secure Socket Layer”，意为“安全套接层”，是一种加密通信技术，用于保证数据在网络上传输的安全  性，避免被截取、窃听和篡改。目前，SSL 被广泛地应用于 Web 浏览器与服务器之间的身份  认证和数据加密。</p><p>Load balancing（负载平衡）<br>在路由选择中，路由器在它所有的到目的端地址均是同样距离的  网络端口上分配业务量的能力。一个好的负载平衡算法使用线路速度和可靠性信息两者。负载平衡增加网段的使用率，从而增加有效的网络带宽。</p><p>HTTP<br>超文本传输协议，一种控制网络信息传输的协议，通常出现在地址栏或统一资源定位符的前面。</p><p>HTML<br>超文本标记语言，设计网页时实用的标准互联网编程语言。它使信息能够呈现所包含的指向其他相关文件的链接。</p><p>URL<br>统一资源定位符，指独一无二的互联网地址。</p><p>绝对URL<br>是指 Internet 上资源的完整地址，其形式通常如下：协议://主机名[/[路径/]资源  文件名]</p><p>相对 url<br>相对 URL 是指 Internet 上资源相对于当前页面的地址，它包含从当前页面指向目标页面的路径。当使用相对 URL 时，可以使用与 DOS 文件目录类似的特殊符号：点（.）和双点（…）， 分别表示当前目录和上一级目录。相对 URL 本身并不能唯一资源，但浏览器会根据当前页面的绝对 URL 正确理解相对 URL。</p><p>404 错误<br>HTTP 404  错误意味着链接指向的网页不存在，即原始网页的URL失效。</p><p>Cookie<br>一种由网站发出并存储在用户的硬盘内的文本文件，网站用它来储存/检索每个访问者的信息。Cookie 存储信息的范围从每个访问者唯一的单独编号一直到有关个人喜好的详细信息和用户提供的人口统计信息。一旦用户收到一个 Cookie，其中将包含该用户所做出的每个网页请求信息。这就使网站的日志文件能够跟踪每个访问者访问网站的活动。Cookie信息还可用于个性化提供给用户的内容，包括广告——  某些广告滚动软件可以识别出用户刚刚看到过哪一个广告，然后将另一个不同的广告滚动  到下一个网页视图中送出。</p><p>Session<br>在计算机中，尤其是在网络应用中，称为“会话控制”。具体到 Web 中的 Session 指的就是用户在浏览某个网站时，从进入网站到关闭这个网站所经过的这段时间，也就是用户浏览这个网站所花费的时间。因此从上述的定义中我们可以看到，Session 实际上是一个  特定的时间概念。</p><p>CMS<br>内容管理系统。它具有许多基于模板的优秀设计，可以加快网站开发的速度和减少开发的成本。CMS 的功能并不只限于文本处理，它也可以处理图片、Flash 动画、声像流、图像甚至电子邮件档案。</p><p>开放平台<br>（Open Platform）在软件业和网络中，开放平台是指软件系统通过公开其应用程序编程接口（API  ）或函数（function)来使外部的程序可以增加该软件系统的功能或使用该软件系统的资源  ，而不需要更改该软件系统的源代码。</p><p>API<br>Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</p><p>SDK<br>（全称：Software Development Kit，软件开发工具包）一般都是一些软件工程师为特定的软件包、软件框架、硬件平台、  操作系统等建立应用软件时的开发工具的集合。软件开发工具包广义上指辅助开发某一类  软件的相关文档、范例和工具的集合。</p><p>Native app<br>而 App 因为位于平台层上方，向下访问和兼容的能力会比较好一些，可以支持在线或离线，消息推送或本地资源访问，摄像拨号功能的调取。但是由于设备碎片化，App 的开发成本要高很多，维持多个版本的更新升级比较麻烦，用户的安装门槛也比较高。但是比较乐观的是，App  store 培养了一种比较好的用户付费模式，所以在 Apple 的生态圈里，开发者的盈利模式是一种明朗状态，其他 market 也在往这条路上靠拢。</p><p>Web app<br>Web 无需安装，对设备碎片化的适应能力优于 App，它只需要通过 XHTML、CSS 和 JavaScript 就可以在任意移动浏览器中执行。随着 iPhone 带来的 WebKit 浏览体验升级，使得专为 iPhone 等有 WebKit 浏览内核的移动设备开发的 Web 应用，也有了如 App 一般流畅的用户体验。</p><p>Html5<br>HTML5 提供了一些新的元素和属性，例如<nav>（网站导航块）和<footer>。这种标签将有利于搜索引擎的索引整理，同时更好的帮助小屏幕装置和视障人士使用，除此之外，还为其他浏览要素提供了新的功能。</footer></nav></p><p>大数据<br>所涉及的资料量规模巨大到无法透过目前主流软件工具，在合理时间内达到撷取  、管理、处理、并整理成为帮助企业经营决策更积极目的的资讯。我国对大数据的搜集利  用主要体现在电子商务领域：电商通过物流掌握用户数据，进行线上线下联动；通过分析购买商品的数据，精确进行商品推荐等。</p><p>数据挖掘<br>一般是指从大量的数据中通过算法搜索隐藏于其中信息的过程。数据挖掘通常与  计算机科学有关，并通过统计、在线分析处理、情报检索、机器学习、专家系统（依靠过去的经验法则）和模式识别等诸多方法来实现上述目标。</p><p>机器学习<br>(Machine Learning, ML)是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多  门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新  组织已有的知识结构使之不断改善自身的性能。  它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域  ，它主要使用归纳、综合而不是演绎。</p><p>云存储<br>是在云计算(cloud computing)概念上延伸和发展出来的一个新的概念，是指通过集群应用、网格技术或分布式文件系统等功能，将网络中大量各种不同类型的存储设备通过应用软件集合起来协同工作，共同对外提供数据存储和业务访问功能的一个系统。当云计算系统运算和处理的核心是大量数据的存储和管理时，云计算系统中就需要配置大量的存储设备，那么云计算系统  就转变成为一个云存储系统，所以云存储是一个以数据存储和管理为核心的云计算系统。</p><p>NFC<br>（Near Field Communication，NFC），又称近距离无线通信，是一种短距离的高频无线通信技术，允许电子设备之间进行非接触式点对点数据传输（在十厘米内）交换数据。</p><p>RFID<br>射频识别即 RFID（Radio  Frequency IDentification）技术，又称电子标签、无线射频识别，是一种通信技术，可通过无线电  讯号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立机械或光学接触  。</p><p>VR<br>Virtual  Reality 即虚拟现实（简称 VR），是由美国 VPL 公司创建人拉尼尔 Jaron  Lanier，在 20 世纪 80 年代初提出的。其具体内涵是：综合利用计算机图形系统和各种现实及控制等接口设备，在计算机上生成的，可交互的三维环境中提供沉浸感觉的技术。其中，计算机生成的，可交互的三维环境成为虚拟环境，即 Virtual Environment（简称 VE），虚拟现实技术实现的载体是虚拟现实仿真平台，即 Virtual Reality Platform（简称 VRP）。</p><p>其他</p><p>SWOT 分析<br>用于对企业的市场地位进行评估的体系，包括优势、劣势、机遇和威胁。优势和劣势都是企业可以改变的内部因素。机遇和威胁则是企业无法控制但是又必须制定应对  措施的外部因素。</p><p>Prototype  产品原型<br>可以概括的说是整个产品面市之前的一个框架设计。以网站注册作为例子,整个前期的交互设计流程图之后,就是原形开发的设计阶段,简单的来说是将页面的模块、元素、人机交互的形式，利用线框描述的方法，将产品脱离皮肤状态下更加具体跟生动的进行表达。</p><p>Flow Chart 流程图<br>是流经一个系统的信息流、观点流或部件流的图形代表，使用图形表示算法的思路。</p><p>MRD 市场需求文档<br>是产品项目由“准备”阶段进入到“实施”阶段的第一文档，其作用就是  “对年度产品中规划的某个产品进行市场层面的说明”。</p><p>BRD 商业需求文档<br>是基于商业目标或价值所描述的产品需求内容文档（报告）。其核心的用途就是用于产品在投入研发之前，由企业高层作为决策评估的重要依据。其内容涉及市场分析，销售策略，盈利预测等，通常是供决策层们讨论的演示文档，一般比较短小精炼，没有产品细节。</p><p>PRD 产品需求文档<br>是产品项目由“概念化”阶段进入到“图纸化”阶段的最主要的一个文档，其作用就是“对MRD 中的内容进行指标化和技术化”。</p><p>AB 测试<br>本质上是个分离式组间实验，A/B 测试的目的在于通过科学的实验设计、采样样本代表性、流量分割与小流量测试等方式来获得具有代表性的实验结论，并确信该结论在推广  到全部流量可信。</p><p>灰度发布<br>是指在黑与白之间，能够平滑过渡的一种发布方式。AB test 就是一种灰度发布方式，让一部分用户继续用 A，一部分用户开始用 B，如果用户对 B 没  有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。灰度发布可以保证整  体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><p>快速检查清单  (Check list)<br>为了达到优化的目标，整理了一个简易的 checklist，方便在走查时对架构、布局、内容、行为四个方面对照检查。</p><p>FAQ<br>是英文 Frequently Asked Questions 的缩写，中文意思就是“经常问到的问题”，或者更通俗地叫做“常见问题解答  ”。</p><p>MVP（Minimum Viable Product  –  最简化可实行产品）<br>一种产品理论，它的重点就是制作的成本要极低，但是却能展示最  终产品的主要特色。作用就是让你拿来接触客户，从很早就根据客户的回馈来改进你的产品。</p><p>职位、职业或部门相关<br>CEO 首席执行官<br>COO 首席运营官<br>CMO 首席市场官<br>CFO 首席财务官<br>VP  副总裁<br>PM  产品经理、项目经理<br>RD  研发<br>OP  运营<br>UI  设计<br>UED  用户体验<br>BD  商务拓展<br>AE  客户执行<br>PR  公关<br>HR  人力资源<br>HRD  人力资源总监<br>KA  大客户部门</p><p>Soho<br>即 Small Office Home Office，家居办公，大多指那些专门的自由职业者。</p><p>Geek<br>极客是一群以创新、技术和时尚为生命意义的人，这群人不分性别，不分年龄，共同的战斗在新经济、尖端技术和世界时尚风潮的前线，共同为现代的电子化社会文化做出自己的贡献。</p><p>淘宝客<br>是指基于阿里妈妈平台帮助卖家推广商品并获取佣金的人。淘宝客推广是一种按成  交计费的推广模式，淘宝客只要从淘宝客推广专区获取商品代码，布置到您要推广的地方，等买家（包括您自己）经过您的推广(链接、个人网站、博客或者社区发的帖子)进入淘  宝卖家店铺完成购买后，就可得到由卖家支付的佣金。</p><p>淘拍档<br>即淘宝网优质电子商务服务提供商，经过淘宝网从淘宝服务商中严格审核，他们被授予“淘拍档”称号，拥有“淘拍档”授牌。常用缩写 TP。</p><p>Aidma 模型<br>该法则于 1898 年由美国广告学家 E.S.刘易斯最先提出。A、I、D、M、A 的含义分别为：A(At tention)引起注意；I  (Interest)产生兴趣；D(Desire)培养欲望；M(Memory)形成记忆；A(Action)促成行动。所谓 AIDMA 法则，是指在消费者从看到广告，到发生购物行为之间，动态式地引导其心理过  程，并将其顺序模式化的一种法则。  其过程是首先消费者，注意到(attention)该广告，其次感到兴趣(interest)而阅读下去，再者产生想买来试一试的欲望(desire)。然后记住  (memory)该广告的内容最后产生购买行为(action)。这种广告发生功效而引导消费者产生  的心理变化，就称为 AIDMA 法则。</p><p>长尾理论<br>网络时代兴起的一种新理论，由于成本和效率的因素，当商品储存流通展示的场地和渠道 足够宽广，商品生产成本急剧下降以至于个人都可以进行生产，并且商品的销售成本急剧 降低时，几乎任何以前看似需求极低的产品，只要有卖，都会有人买。这些需求和销量不高的产品所占据的共同市场份额，可以和主流产品的市场份额相比，甚至更大。</p><p>六度空间理论<br>又名“六度分割理论”、“小世界理论”等，起源于一个数学领域的猜想。该理论的核心是：你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过六个人你就能够认识任何一个陌生人。</p><p>七次印象理论<br>广告学的一个理论，含义是：一个广告通常需要被目标受众反复看 7 次以后才能形成深刻稳定的印象（被人记住）。  该理论的主要应用场景：各类品牌广告。极端案例：著名的恒源祥恶搞广告事件。</p><p>八秒法则<br>网络营销领域的一个重要法则，主要原理为：着陆页的打开速度对访客的访问意愿具有较大的影响，如果能在 3 秒内打开，则访客的体验是良好的；如果超过 5 秒，则访客将产生焦  虑和烦躁的情绪；而 8 秒是多数访客忍耐的临界点，如果着陆页在 8 秒内没有完全打开，多数访客将直接关闭该网页（从而造成访客流失）。</p><p>避风港原则<br>避风港原则是互联网著作权领域的一个司法原则，最早来自美国 1998 年制定的《数字千年版权法案》（DMCA 法案）。它的含义是：发生著作权侵权案件时，如果 ISP（网络服务提供商）只提供空间服务，并不制作网页内容，那么当 ISP 被告知侵权时，有删除相关信息的义 务，否则就被视为侵权。如果侵权内容既不在 ISP 的服务器上存储，又没有被告知哪些内容应该删除，则 ISP 不承担侵权责任。后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。避风港原则包括两  部分，“通知+移除”（notice－take down procedure）。由于网络中介服务商没有能力进行事先内容审查，一般事先对侵权信息的存在不知情。所以，采取“通知+移除”规则，是对网络中介服务商间接侵权责任的限制。</p><hr><p>作者：Acelit<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/acelit/article/details/74357277" target="_blank" rel="noopener">https://blog.csdn.net/acelit/article/details/74357277</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据统计分析篇&lt;br&gt;
PC 网站&lt;/p&gt;
&lt;p&gt;Traffic&lt;br&gt;
流量，在互联网领域内，统计网站使用量的笼统用语。&lt;/p&gt;
&lt;p&gt;UV&lt;br&gt;
Unique Vister，独立访客。&lt;/p&gt;
&lt;p&gt;PV&lt;br&gt;
Page View，即网站被浏览的总次数。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="English" scheme="https://bobit.github.io/categories/English/"/>
    
    
      <category term="英语" scheme="https://bobit.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="互联网" scheme="https://bobit.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
      <category term="转载" scheme="https://bobit.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 学习总结</title>
    <link href="https://bobit.github.io/posts/33388948.html"/>
    <id>https://bobit.github.io/posts/33388948.html</id>
    <published>2017-11-13T04:19:17.000Z</published>
    <updated>2018-12-21T12:55:19.535Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB GUI（ Robo 3T） Shell使用及操作</p><h2 id="robo-3t-下载及使用"><a class="markdownIt-Anchor" href="#robo-3t-下载及使用"></a> Robo 3T 下载及使用</h2><p>之前叫 Robomongo，后面被收购了，改名 Robo 3T 。<br>下载链接：<a href="https://robomongo.org/download" target="_blank" rel="noopener">https://robomongo.org/download</a></p><p>安装版：安装步骤省略，下一步下一步…<br>解压版：解压即可。<br>图形界面，连接默认，取个名字就行。<br>连接成功，可以愉快的使用了，不用总是敲命令了，简洁方便，多种显示。<br>软件右边可以切换显示样式。</p><h2 id="robo-3t-shell-操作"><a class="markdownIt-Anchor" href="#robo-3t-shell-操作"></a> Robo 3T Shell 操作</h2><p>1、批量插入（默认是不支批量操作，只能用for循环。）<br>2、$type 操作符，基于BSON类型来检索集合中匹配的数据类型，并返回结果。<br>先增加一些数据，然后查询出来 （同一界面，需要选中执行的一行，不然会一直执行第一个命令。）<br>3、Limit与Skip的用法<br>查询文档中两条记录<br>第一个 {} 放 where 条件，为空表示返回集合中所有文档。<br>第二个 {} 指定那些列显示和不显示 （0表示不显示 1表示显示)。<br>查询显示第2、3条文档数据<br>skip()方法默认参数为 0 。<br>skip 和 limit 结合就能实现分页。<br>排序 sort() 方法<br>索引 ensureIndex() 方法<br>多个字段索引：db.student.ensureIndex({“name”:1,“hobby”:-1})<br>聚合 aggregate()<br>这里只操作一种方法，分组并统计，其它的可以查看相关用法和文档。<br>总结：常用的一些基本用法就这些，高级用法可以慢慢再研究。</p><h2 id="mongodb-insert和save的相同点和区别"><a class="markdownIt-Anchor" href="#mongodb-insert和save的相同点和区别"></a> mongodb insert()和save()的相同点和区别</h2><h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3><p>​若新增的数据中存在主键 ，insert() 会提示错误，而save() 则更改原来的内容为新内容。<br>​如：<br>​已存在数据：  {_id : 1, &quot; name &quot; : &quot; n1 &quot; }，再次进行插入操作时，<br>​insert({_id : 1, &quot; name &quot; : &quot; n2 &quot; })    会报主键重复的错误提示<br>​save({ _id : 1, &quot; name &quot; : &quot; n2 &quot; })     会把 n1 修改为  n2  。</p><h3 id="相同点"><a class="markdownIt-Anchor" href="#相同点"></a> 相同点：</h3><p>​若新增的数据中没有主键时，会增加一条记录。<br>​已存在数据：  { _id : 1, &quot; name &quot; : &quot; n1 &quot; }，再次进行插入操作时，<br>​insert({ &quot; name &quot; : &quot; n2 &quot; })    插入的数据因为没有主键，所以会增加一条数据<br>​save({  &quot; name &quot; : &quot; n2 &quot; })   增加一条数据。</p><h2 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h2><p>​    $gt -------- greater than  &gt;<br>​    $gte --------- gt equal  &gt;=<br>​    $lt -------- less than  &lt;<br>​    $lte --------- lt equal  &lt;=<br>​    $ne ----------- not equal  !=<br>​    $eq  --------  equal  =</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MongoDB GUI（ Robo 3T） Shell使用及操作&lt;/p&gt;
&lt;h2 id=&quot;robo-3t-下载及使用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#robo-3t-下载及使用&quot;&gt;&lt;/a&gt; Robo 3T 下载及使用&lt;/h2&gt;
&lt;p
      
    
    </summary>
    
      <category term="分布式" scheme="https://bobit.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="MongoDB" scheme="https://bobit.github.io/tags/MongoDB/"/>
    
      <category term="Robo 3T" scheme="https://bobit.github.io/tags/Robo-3T/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 官方 Docker 镜像的使用</title>
    <link href="https://bobit.github.io/posts/ac33bd8a.html"/>
    <id>https://bobit.github.io/posts/ac33bd8a.html</id>
    <published>2017-11-12T14:20:17.000Z</published>
    <updated>2018-12-21T12:57:32.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取镜像"><a class="markdownIt-Anchor" href="#获取镜像"></a> 获取镜像</h2><p>首先是pull image，这里我拉取的是5.6.35:<br>docker pull mysql:5.6.35</p><h2 id="安全使用"><a class="markdownIt-Anchor" href="#安全使用"></a> 安全使用</h2><p>docker run --name mysql -p 6666:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.6.35<br>试着用客户端连接，成功了，查询mysql.user表发现允许从任何地方用root访问，这太不安全了！<br>连接到bash:<br>docker exec -it mysql bash<br>运行mysql，竟然有！</p><p>下面修改为安全使用：<br>就是基本的操作，收回root权限，建库，开用户……等等<br>数据库文件在哪？还有，字符集不是UTF-8？？？</p><h2 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h2><p>docker run --name mysql -p 6666:3306 -v /home/bobit/docker/mysql/5.6.35/data:/var/lib/mysql -v /home/bobit/docker/mysql/5.6.35/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6.35</p><p>docker run --name mysql -p 6666:3306 -v /home/bobit/docker/mysql/5.6.35/data:/var/lib/mysql -v /home/bobit/docker/mysql/5.6.35/conf:/etc/mysql/conf.d -d mysql:5.6.35</p><h2 id="进入容器"><a class="markdownIt-Anchor" href="#进入容器"></a> 进入容器</h2><p>docker exec -it mysql bash</p><h2 id="登录mysql有root权限"><a class="markdownIt-Anchor" href="#登录mysql有root权限"></a> 登录MYSQL（有ROOT权限）。</h2><p>mysql -u root -p<br>输入密码</p><h2 id="修改root密码"><a class="markdownIt-Anchor" href="#修改root密码"></a> 修改root密码</h2><p>Mysql5.6使用如下方式：<br>use mysql<br>update user set password=password(“123123”) where user=“root”;</p><p>MySQL5.7及后续版本 改密码无password字段（未测试，如下）<br>MySQL5.7版本密码设置，MySQL 设置的密码中必须至少包含一个大写字母、一个小写字母、一个特殊符号、一个数字，<br>密码长度至少为8个字符<br>update user set authentication_string=password(“123123”) where user=“root”;</p><h2 id="为用户创建一个数据库testdb"><a class="markdownIt-Anchor" href="#为用户创建一个数据库testdb"></a> 为用户创建一个数据库(testdb)</h2><p>mysql&gt;create database testdb;</p><h2 id="创建用户同时授权"><a class="markdownIt-Anchor" href="#创建用户同时授权"></a> 创建用户同时授权</h2><p>授权 bobit 用户拥有 testdb 数据库的所有权限<br>mysql&gt; grant all privileges on testdb.* to bobit@localhost identified by ‘123456’;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; flush privileges;<br>Query OK, 0 rows affected (0.01 sec)<br>PS:必须执行flush privileges,刷新系统权限表;</p><h2 id="添加远程登录用户"><a class="markdownIt-Anchor" href="#添加远程登录用户"></a> 添加远程登录用户</h2><p>mysql&gt; GRANT ALL PRIVILEGES ON <em>.</em> TO bobit@&quot;%&quot; IDENTIFIED BY ‘123456’;<br>Query OK, 0 rows affected (0.00 sec)</p><p>说明：<br>（1）grant all 赋予所有的权限<br>（2）testdb.* 数据库 testdb 中所有的表<br>（3）newuser 用户名<br>（4）@localhost 在本地电脑上的 mysql server 服务器<br>（5）identfified by ‘password’ 设置密码</p><h2 id="备注"><a class="markdownIt-Anchor" href="#备注"></a> 备注</h2><p>因MYSQL5.7版本sql_mode=only_full_group_by问题，暂时降低版本到5.6.35</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;获取镜像&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#获取镜像&quot;&gt;&lt;/a&gt; 获取镜像&lt;/h2&gt;
&lt;p&gt;首先是pull image，这里我拉取的是5.6.35:&lt;br&gt;
docker pull mysql:5.6.35&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="Docker" scheme="https://bobit.github.io/categories/Docker/"/>
    
    
      <category term="docker" scheme="https://bobit.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>常用易错单词</title>
    <link href="https://bobit.github.io/posts/62f2c90a.html"/>
    <id>https://bobit.github.io/posts/62f2c90a.html</id>
    <published>2017-11-11T15:29:17.000Z</published>
    <updated>2018-12-21T13:10:31.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="state-condition-situation-的区别"><a class="markdownIt-Anchor" href="#state-condition-situation-的区别"></a> state condition situation 的区别</h2><p>都含&quot;情况&quot;的意思。<br>state：比较常用，各种状态都可以用它，但是它更着重于一种心理状态或者物理状态。指&quot;人或物存在或所处的状态&quot;, 但不着重于&quot;这种状态和具体原因或条件的关系&quot;, 如: He is in a good state.他身体健康。水在标准大气压下 100 摄氏度时是什么状态？state。<br>condition：指&quot;由于一定的原因、条件或环境所产生的特定情况&quot;, 如: His condition will not permit him to travel.他的情况不允许他旅游。<br>situation：指&quot;多种具体情况造成的综合状态&quot;, 常着重&quot;这种状态的影响或和处于该状态的事物的关系&quot;, 如: We are in difficult situation. 我们处于困境。<br>status：用在人的身上一般是其身份和地位，作“状态，情形”讲时，多指政治和商业，指物时相当于 situation。如：最近的国际形式如何？status。</p><h2 id="生词本"><a class="markdownIt-Anchor" href="#生词本"></a> 生词本</h2><p>mediocre 英 [,miːdɪ’əʊkə]  美 [,midɪ’okɚ]<br>adj. 普通的；平凡的；中等的</p><p>demonstrate英 ['demənstreɪt]美 ['dɛmən’stret]<br>vt. 证明；展示；论证<br>vi. 示威</p><p>proficiency英 [prə’fɪʃ(ə)nsɪ]美 [prə’fɪʃənsi]<br>n. 精通，熟练</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;state-condition-situation-的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#state-condition-situation-的区别&quot;&gt;&lt;/a&gt; state condition situation 的区别
      
    
    </summary>
    
      <category term="English" scheme="https://bobit.github.io/categories/English/"/>
    
    
      <category term="英语" scheme="https://bobit.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Python高级</title>
    <link href="https://bobit.github.io/posts/bce7e83e.html"/>
    <id>https://bobit.github.io/posts/bce7e83e.html</id>
    <published>2017-09-02T01:00:12.000Z</published>
    <updated>2018-12-21T13:34:36.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="toc"><a class="markdownIt-Anchor" href="#toc"></a> [TOC]</h2><h2 id="python3列表排序"><a class="markdownIt-Anchor" href="#python3列表排序"></a> Python3列表排序</h2><pre><code>python语言中的列表排序方法有4个：利用步长对序列进行倒序取值、reverse反向排序、sort正序排序、sorted可以获取排序后的列表。</code></pre><h3 id="利用步长对序列进行倒序取值"><a class="markdownIt-Anchor" href="#利用步长对序列进行倒序取值"></a> 利用步长对序列进行倒序取值</h3><pre><code>str_list = ['a', 'b', 'd', 'c']print(str_list[::-1] ) # 输出['c', 'd', 'b', 'a']</code></pre><h3 id="reverse方法"><a class="markdownIt-Anchor" href="#reverse方法"></a> reverse()方法</h3><pre><code>str_list = ['a', 'b', 'd', 'c']str_list.reverse()print(str_list)#输出['c', 'd', 'b', 'a']reverse列表反转排序：是把原列表中的元素顺序从左至右的重新存放，而不会对列表中的参数进行排序整理。如果需要对列表中的参数进行整理，就需要用到列表的另一种排序方式sort正序排序。</code></pre><h3 id="sort排序方法"><a class="markdownIt-Anchor" href="#sort排序方法"></a> sort()排序方法</h3><pre><code>此函数方法对列表内容进行正向排序，排序后的新列表会覆盖原列表（id不变），也就是sort排序方法是直接修改原列表list排序方法。正向排序str_list = ['a', 'b', 'd', 'c']str_list.sort()print(str_list)#输出['a', 'b', 'c', 'd']反向排序str_list = ['a', 'b', 'd', 'c']str_list.sort(reverse=True)print(str_list)  # 输出['d', 'c', 'b', 'a']问题：print(str_list.sort())返回值为None原因：list.sort()功能是针对列表自己内部进行排序， 不会有返回值， 因此返回为None。解决：解决办法：   1）   str_list.sort()   print(str_list)   2)   print(sorted(str_list))</code></pre><h3 id="sorted方法"><a class="markdownIt-Anchor" href="#sorted方法"></a> sorted()方法</h3><pre><code>即可以保留原列表，又能得到已经排序好的列表sorted()操作方法如下：正向排序str_list = ['a', 'b', 'd', 'c']str_list_sorted = sorted(str_list)print(str_list)#输出['a', 'b', 'd', 'c']print(sorted(str_list))#输出['a', 'b', 'c', 'd']反向排序str_list = ['a', 'b', 'd', 'c']str_list_sorted = sorted(str_list,reverse=True)print(str_list)#输出['a', 'b', 'd', 'c']print(sorted(str_list,reverse=True))#输出['d', 'c', 'b', 'a'] sorted()方法可以用在任何数据类型的序列中，返回的总是一个列表形式：print(sorted('iloveapitest@163.com'))#输出['.', '1', '3', '6', '@', 'a', 'c', 'e', 'e', 'i', 'i', 'l', 'm', 'o', 'o', 'p', 's', 't', 't', 'v']</code></pre><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><pre><code>不是根据首字母排序,可以理解为列表倒序可以使用reverse()，根据字母顺序排序可以使用sorted(list)函数；根据字母相反顺序排序可以使用sorted(list, reverse = True)函数；  </code></pre><h2 id="切片操作"><a class="markdownIt-Anchor" href="#切片操作"></a> 切片操作</h2><h3 id="切片操作的方法"><a class="markdownIt-Anchor" href="#切片操作的方法"></a> 切片操作的方法</h3><pre><code>对于具有序列结构的数据来说，切片操作的方法是：consequence[start_index: end_index: step]。start_index：表示是第一个元素对象，正索引位置默认为0；负索引位置默认为 -len(consequence)end_index：表示是最后一个元素对象，正索引位置默认为 len(consequence)－1；负索引位置默认为 -1。step：表示取值的步长，默认为1，步长值不能为0。</code></pre><h3 id="几种常见的表达"><a class="markdownIt-Anchor" href="#几种常见的表达"></a> 几种常见的表达</h3><pre><code>con[start_index: ]：缺省end_index，表示从start_index开始到序列中最后一个对象。con[: end_index］：缺省start_index，表示从序列中第一个对象到end_index-1之间的片段。con[:]：缺省start_index和end_index，表示从第一个对象到最后一个对象的完整片段。con[::step]：缺省start_index和end_index，表示对整个序列按照索引可以被step整除的规则取值。在使用单索引对序列寻址取值时，你所输入的索引值必须是处于 -len(consequence) 到 len(consequence)-1 之间的值，否则会报错提示索引值超出范围。如：list = [1, 2, 3, 4, 5, 6, 7]print(list[len(list) - 1])print(list[-len(list)])#print(list[len(list)])</code></pre><h3 id="利用步长对序列进行倒序取值-2"><a class="markdownIt-Anchor" href="#利用步长对序列进行倒序取值-2"></a> 利用步长对序列进行倒序取值</h3><pre><code>list_a=[1,2,3,4,5,6,7]list_b=(1,2,3,4,5,6,7)list_c='Let me show you list little thing'print(list_a[::-1])print(list_b[::-1])print(list_c[::-1])list_a.reverse()print(list_a)#相对reverse而言，切片的方法不会改变列表的结构，所以这是在实际应用中比较有用的一个技巧。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;toc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#toc&quot;&gt;&lt;/a&gt; [TOC]&lt;/h2&gt;
&lt;h2 id=&quot;python3列表排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#python3列表排序&quot;&gt;
      
    
    </summary>
    
      <category term="Python" scheme="https://bobit.github.io/categories/Python/"/>
    
    
      <category term="python" scheme="https://bobit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda学习总结</title>
    <link href="https://bobit.github.io/posts/8ec8f94.html"/>
    <id>https://bobit.github.io/posts/8ec8f94.html</id>
    <published>2017-09-02T01:00:10.000Z</published>
    <updated>2018-12-21T13:34:30.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装anaconda和python"><a class="markdownIt-Anchor" href="#安装anaconda和python"></a> 安装Anaconda和Python</h2><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Anaconda是专业的数据科学计算环境，已经集成绝大部分包和工具，不需要多余的安装和调试，使用方便。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>Anaconda在官网下载各个操作系统的安装包，网址：<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">https://www.anaconda.com/download/</a><br>双击下载下来的.exe文件，安装时将两个选项都选上，将安装路径写入环境变量，然后等待完成就可以了。<br>安装完成后，打开Windows的命令提示符输入conda list 就可以查询现在安装了哪些库，常用的numpy, scipy等安装上就可以。</p><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><p>安装其他包，可以运行conda install ***<br>更新某个包版本不是最新的，运行 conda update ***</p><h2 id="jupyter"><a class="markdownIt-Anchor" href="#jupyter"></a> Jupyter</h2><p>Jupyter，是一个交互式的笔记本，能快速创建程序，支持实时代码、可视化和Markdown语言，数据分析最常用。<br>在“开始”菜单中“Anaconda3”文件下找到“Jupyter Notebook”，点击进入，它会自动创建一个本地环境localhost。<br>点击界面右上角的new，创建一个Python文件。到此Anaconda安装就已经全部成功了，我们就可以在这个界面进行输入输出了。</p><h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2><p>Python版本建议3.0以上，现在最新版本是3.6，不要选择2.7的版本，否则你会被无尽的中文编码问题困扰</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装anaconda和python&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装anaconda和python&quot;&gt;&lt;/a&gt; 安装Anaconda和Python&lt;/h2&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
      <category term="Python" scheme="https://bobit.github.io/categories/Python/"/>
    
    
      <category term="Anaconda" scheme="https://bobit.github.io/tags/Anaconda/"/>
    
      <category term="python" scheme="https://bobit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="https://bobit.github.io/posts/99832f47.html"/>
    <id>https://bobit.github.io/posts/99832f47.html</id>
    <published>2017-09-01T01:00:11.000Z</published>
    <updated>2018-12-21T13:34:34.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符"></a> 算术运算符</h2><h3 id="算术运算"><a class="markdownIt-Anchor" href="#算术运算"></a> 算术运算</h3><ul><li>加</li></ul><ul><li>减</li></ul><ul><li>乘<br>/ 除（浮点数除法）<br>% 取模（相除后的余数）<br>** 取幂（注意 ^ 并不执行该运算，你可能在其他语言中见过这种情形）<br>// 取整除（表示整数除法,相除后向下取整到最接近的整数）</li></ul><h3 id="优先级"><a class="markdownIt-Anchor" href="#优先级"></a> 优先级</h3><p>从最高到最低优先级的所有运算符：</p><pre><code>运算符描述**指数 (最高优先级)~ + -按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)* / % //乘，除，取模和取整除+ -加法减法&gt;&gt; &lt;&lt;右移，左移运算符&amp;位 'AND'^ |位运算符&lt;= &lt; &gt; &gt;=比较运算符&lt;&gt; == !=等于运算符= %= /= //= -= += *= **=赋值运算符is is not身份运算符in not in成员运算符not and or逻辑运算符</code></pre><h2 id="变量和赋值运算符"><a class="markdownIt-Anchor" href="#变量和赋值运算符"></a> 变量和赋值运算符</h2><h3 id="命名"><a class="markdownIt-Anchor" href="#命名"></a> 命名</h3><ol><li>只能在变量名称中使用常规字母、数字和下划线。不能包含空格，并且需要以字母或下划线开头。</li><li>不能使用保留字或内置标识符</li></ol><h3 id="保留字"><a class="markdownIt-Anchor" href="#保留字"></a> 保留字</h3><pre><code>False      await      else       import     passNone       break      except     in         raiseTrue       class      finally    is         returnand        continue   for        lambda     tryas         def        from       nonlocal   whileassert     del        global     not        withasync      elif       if         or         yield</code></pre><h2 id="布尔型运算符-比较运算符和逻辑运算符"><a class="markdownIt-Anchor" href="#布尔型运算符-比较运算符和逻辑运算符"></a> 布尔型运算符、比较运算符和逻辑运算符</h2><h3 id="布尔型运算符"><a class="markdownIt-Anchor" href="#布尔型运算符"></a> 布尔型运算符</h3><p>布尔数据类型存储的是值 True 或 False，通常分别表示为 1 或 0。</p><p>通常有 6 个比较运算符会获得布尔值：</p><h3 id="比较运算符"><a class="markdownIt-Anchor" href="#比较运算符"></a> 比较运算符</h3><pre><code>符号使用情况布尔型运算符5 &lt; 3False小于5 &gt; 3True大于3 &lt;= 3True小于或等于3 &gt;= 5False大于或等于3 == 5False等于3 != 5True不等于</code></pre><h3 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符：</h3><pre><code>逻辑使用情况布尔型运算符5 &lt; 3 and 5 == 5Falseand - 检查提供的所有语句是否都为 True5 &lt; 3 or 5 == 5Trueor - 检查是否至少有一个语句为 Truenot 5 &lt; 3Truenot - 翻转布尔值</code></pre><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><p>将字符串与整数相乘，会得出由原始字符串重复多次构成的新字符串，类型是字符串。<br>len 仅适用于“序列（例如字符串、字节、元组、列表或范围）或集合（例如字典、集合或冻结集合）”。</p><h2 id="类型和类型转换"><a class="markdownIt-Anchor" href="#类型和类型转换"></a> 类型和类型转换</h2><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型：</h3><p>整型<br>浮点型<br>布尔型<br>字符串</p><h3 id="类型检查"><a class="markdownIt-Anchor" href="#类型检查"></a> 类型检查</h3><p>type()，它可以用来检查你所处理的任何变量的数据类型。</p><h3 id="字符串方法"><a class="markdownIt-Anchor" href="#字符串方法"></a> 字符串方法</h3><p>方法就像某些你已经见过的函数：<br>len(“this”)<br>type(12)<br>print(“Hello world”)<br>上述三项都是函数。注意，它们使用了小括号并接受一个参数。<br>type 和 print 函数可以接收字符串、浮点型、整型和很多其他数据类型的参数，函数 len 也可以接受多种不同数据类型的参数，稍后你将在这节课中详细了解。<br>python 中的方法和函数相似，但是它针对的是你已经创建的变量。方法特定于存储在特定变量中的数据类型。<br>字符串的每个方法都接受字符串本身作为该方法的第一个参数。但是，它们还可以接收其他参数。count 和 find 方法都接受另一个参数。但是，islower 方法不接受参数。如果我们要在变量中存储浮点数、整数或其他类型的数据，可用的方法可能完全不同！</p><h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2><p>列表可排序，你可以使用 .append 向列表中添加项目，列表项的索引始终以 0 开始。</p><h2 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h2><p>集合是无序的，因此项目的出现顺序可能不一致，你可以使用 .add 向集合中添加项目。和字典及列表一样，集合是可变的。<br>集合中不能有重复项，不能对集合排序。对于这两个属性，更适合使用列表。</p><h2 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> 字典</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>键必须是唯一的(键必须是不可变的，如字符串，数字或元组)，值可以取任何数据类型。<br>字典是无序的，因此不能排序。不能使用 .append 向字典中添加项目。<br>字典中的每项都包含两部分（键和值），字典中的项目是无序的，我们在这节课见到了嵌套字典示例。<br>但这里有一点需要注意，Python中其他数据结构也是可以嵌套的，不过嵌套字典在我们的使用中会更为普遍一些，所以我们在这里选择了这一项。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算术运算符&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算术运算符&quot;&gt;&lt;/a&gt; 算术运算符&lt;/h2&gt;
&lt;h3 id=&quot;算术运算&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算术运算&quot;&gt;&lt;/a&gt; 算术运算&lt;
      
    
    </summary>
    
      <category term="Python" scheme="https://bobit.github.io/categories/Python/"/>
    
    
      <category term="python" scheme="https://bobit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>算法的时间复杂度和空间复杂度</title>
    <link href="https://bobit.github.io/posts/19e44aed.html"/>
    <id>https://bobit.github.io/posts/19e44aed.html</id>
    <published>2016-12-21T08:24:25.000Z</published>
    <updated>2018-12-27T15:12:05.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法复杂度"><a class="markdownIt-Anchor" href="#算法复杂度"></a> 算法复杂度</h2><p>算法复杂度分为时间复杂度和空间复杂度，一个好的算法应该具体执行时间短，所需空间少的特点。<br>随着计算机硬件和软件的提升，一个算法的执行时间是算不太精确的。只能依据统计方法对算法进行估算。我们抛开硬件和软件的因素，算法的好坏直接影响程序的运行时间。</p><h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int value = 0;                      // 执行了1次</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;       // 执行了n次</span><br><span class="line">      value += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法执行了 1 + n 次，如果n无限大，我们可以把前边的1忽略，也就是说这个算法执行了n次<br>时间复杂度常用大O符号表示，这个算法的时间复杂度就是O(n).<br>概念： 一般情况下，算法的基本操作重复执行的次数是模块n的某一函数f(n),因此，算法的时间复杂度记做 T(n) = O(f(n))。 随着模块n的增大，算法执行的时间增长率f(n)的增长率成正比，所以f(n)越小，算法 的时间复杂度越低，算法的效率越高。</p><h3 id="计算时间复杂度"><a class="markdownIt-Anchor" href="#计算时间复杂度"></a> 计算时间复杂度</h3><ol><li>去掉运行时间中的所有加法常数。</li><li>只保留最高阶项。</li><li>如果最高阶项存在且不是1，去掉与这个最高阶相乘的常数得到时间复杂度</li></ol><h4 id="例子-2"><a class="markdownIt-Anchor" href="#例子-2"></a> 例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">     for (int j = i; j &lt; n; j++) &#123;</span><br><span class="line">          // do .....</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 i = 0 时 里面的fo循环执行了n次，当i等待1时里面的for循环执行了n -  1次，当i 等于2里里面的fro执行了n - 2次…所以执行的次数是</p><p><img src="../../gitbooks/static/images/19e44aed/131716210919007.png" alt="img"></p><p>根据我们上边的时间复杂度算法</p><ol><li>去掉运行时间中的所有加法常数： 没有加法常数不用考虑</li><li>只保留最高阶项:　只保留 <img src="../../gitbooks/static/images/19e44aed/131716483418199.png" alt="img"></li><li>去掉与这个最高阶相乘的常数:  去掉  <img src="../../gitbooks/static/images/19e44aed/131717237639755.png" alt="img">只剩下 <img src="../../gitbooks/static/images/19e44aed/131717476855630.png" alt="img"><br>最终这个算法的时间复杂度为<img src="../../gitbooks/static/images/19e44aed/131718146698806.png" alt="img"></li></ol><p>再看一个线性的<br>​      for ( int i = 0; i &lt; n; i++) {<br>​          // do …<br>​     }<br>​     因为循环要执行n次所以时间复杂度为O(n)</p><p>其它的我也就不一个一个算了，下面给出了常用的时间复杂度</p><p><img src="../../gitbooks/static/images/19e44aed/1545381733608.png" alt="1545381733608"></p><table><thead><tr><th>排序法</th><th>最差时间分析</th><th>平均时间复杂度</th><th>稳定度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)</td><td>O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)</td><td>稳定</td><td>O(1)</td></tr><tr><td>快速排序</td><td>O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>)</td><td>O(n*<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mo>(</mo></msub><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">log_(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"></span></span></span></span></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo>(</mo></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">^(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8879999999999999em;"></span><span class="strut bottom" style="height:1.138em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>)</td><td>不稳定</td><td>O(log2n)~O(n)</td></tr><tr><td>二叉树排序</td><td>O(n2)</td><td>O(n*log2n)</td><td>不一顶</td><td>O(n)</td></tr><tr><td>插入排序</td><td>O(n2)</td><td>O(n2)</td><td>稳定</td><td>O(1)</td></tr><tr><td>堆排序</td><td>O(n*log2n)</td><td>O(n*log2n)</td><td>不稳定</td><td>O(1)</td></tr><tr><td>希尔排序</td><td>O</td><td>O</td><td>不稳定</td><td>O(1)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法复杂度&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法复杂度&quot;&gt;&lt;/a&gt; 算法复杂度&lt;/h2&gt;
&lt;p&gt;算法复杂度分为时间复杂度和空间复杂度，一个好的算法应该具体执行时间短，所需空间少的特点。&lt;br&gt;
随着计算机硬件和软件的提升，
      
    
    </summary>
    
      <category term="Algorithms" scheme="https://bobit.github.io/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="https://bobit.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>健康美味饺子</title>
    <link href="https://bobit.github.io/posts/2dda6b6e.html"/>
    <id>https://bobit.github.io/posts/2dda6b6e.html</id>
    <published>2016-12-15T00:38:12.000Z</published>
    <updated>2018-12-21T13:33:50.475Z</updated>
    
    <content type="html"><![CDATA[<p>胡萝卜猪肉鸡蛋饺<br>富含维生素A，补肝明目，清热解毒。</p><p>韭菜蘑菇猪肉饺<br>温中开胃，行气活血，补肾助阳，散瘀。</p><p>韭黄三鲜饺<br>鲜贝、海米和瘦肉中含有丰富的锌元素，促进生长发育，提高抵抗力。</p><p>全麦香芹虾肉饺<br>内含丰富的B族维生素和膳食纤维，有助于控制血糖，适合糖尿病病人食用。</p><p>山药豆香鲜肉饺<br>内含山药，有健脾养胃的功效</p><p>香菇鸡肉黄金饺<br>热量较低，膳食纤维高，可降低血脂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;胡萝卜猪肉鸡蛋饺&lt;br&gt;
富含维生素A，补肝明目，清热解毒。&lt;/p&gt;
&lt;p&gt;韭菜蘑菇猪肉饺&lt;br&gt;
温中开胃，行气活血，补肾助阳，散瘀。&lt;/p&gt;
&lt;p&gt;韭黄三鲜饺&lt;br&gt;
鲜贝、海米和瘦肉中含有丰富的锌元素，促进生长发育，提高抵抗力。&lt;/p&gt;
&lt;p&gt;全麦香芹虾肉饺&lt;br&gt;

      
    
    </summary>
    
      <category term="Life" scheme="https://bobit.github.io/categories/Life/"/>
    
    
      <category term="life" scheme="https://bobit.github.io/tags/life/"/>
    
      <category term="eat" scheme="https://bobit.github.io/tags/eat/"/>
    
  </entry>
  
  <entry>
    <title>宝宝晚上睡不安的原因</title>
    <link href="https://bobit.github.io/posts/23c9dee4.html"/>
    <id>https://bobit.github.io/posts/23c9dee4.html</id>
    <published>2016-12-14T23:38:15.000Z</published>
    <updated>2018-12-21T13:33:58.874Z</updated>
    
    <content type="html"><![CDATA[<p>宝宝晚上睡不安的原因很多，应该可以分为两大类：<br>一、外在因素<br>1、饥饿<br>多见于新生儿和三个月之内的宝宝。这时需要哺乳或喂奶来解决。稍大的宝宝如果睡前吃饱，可以排除这个因素。<br>天气干燥的情况下，宝宝夜间可能会口渴，给他补充点水分可以让他安静。<br>2、缺钙<br>缺钙是导致小宝宝睡觉不安稳首要因素之一，大多数MM都会考虑到它。缺钙、血钙降低，引起大脑植物性神经兴奋性增高，导致宝宝夜醒、夜惊、夜间烦躁不安，睡不安稳。解决方案就是给宝宝补钙和维生素D并多晒太阳。<br>A、补钙：每日元素钙300-500mg<br>B、补VD：每日400-800IU<br>3、太热<br>现在的宝宝穿盖多半是偏热的。其实小宝宝凉一点没有关系，太热会使他不舒服，也容易生病。如果室温挺高，又穿着睡袋，再盖上小被子，宝宝自身散热能力差，会感到热而醒来。这时只要减少穿盖即可解决。<br>4、腹胀<br>1岁以内的婴儿都会出现这种情况。如果睡前吃得过饱，或喝奶后没有打嗝排气，小宝宝都会因腹胀而醒来。大点的婴儿多半是睡前几小时内吃了一些难以消化的东西。注意按摩、排气和调整饮食即可解决。积食的宝宝可用点小中药治疗。<br>5、尿湿<br>因尿裤太湿或勒得太紧，也会使宝宝不舒服。有的宝宝想尿尿时不愿轻易尿在尿裤上，也会翻来覆去不安稳。细心的MM观察一下.<br>6、白天太兴奋或环境的变化<br>稍大点的宝宝的睡眠不安也可与白天过度兴奋或紧张、日常生活的变化有关。如出门、睡眠规律改变、搬新屋、有新的保姆和陌生人来。比如老的保姆走了会引起婴儿晚上睡眠不安。经常更换抚养人也使孩子睡眠障碍的发生率明显升高。白天睡的太多也可影响晚上的睡眠。<br>7、出牙或身体不适<br>宝宝出牙期间往往会有睡不安稳的现象。有时几夜反复折腾之后妈妈才发现，宝宝的牙床冒出了白白的小牙。可见出牙还是有些疼痛的。其他疾病当然也会引起睡眠不安。生病或发烧前的夜晚往往是翻覆不宁的。这些都需要细心的观察和判断。<br>二、内在因素<br>小儿的内在因素对睡眠也有影响：大脑神经发育尚未成熟。孩子生理上尚未建立固定的作息时间表。宝宝生物时钟日夜规律的调整，要倚赖宝宝生理成熟度的配合。<br>调查表明，神经系统兴奋性较高的宝宝，生理成熟度往往晚些，容易出现睡眠不安的情况。这种宝宝相对睡眠好的宝宝，性格可能更趋向活跃、外向、敏感。<br>人的睡眠分为深度睡眠和浅度睡眠，夜间约3-4小时交替一次。婴儿和幼儿同样，可能深睡和浅睡的交替时间更短一些，约2-3小时交换一次。大人和许多睡整夜觉的宝宝，在浅度睡眠到来时，可以较好地自我调整，重新进入深度睡眠。而也有许多小宝宝甚至许多大人，无法自我调整入睡，所以就从浅度睡眠中醒来。<br>许多正在吃母乳的宝宝，无法自我调整，心理渴望爱抚，妈妈的乳房无疑是她最大的安慰。当然，有时抱睡、边走边摇等也会有效。尤其随着神经系统的发育和大脑皮层活跃，宝宝越长大越容易无法自我调整。这就是宝宝在四、五个月之后反而睡觉比小时候还要差、醒的次数还要多的原因。<br>排除掉渴饿冷热缺钙腹胀出牙兴奋等等外在因素之后，你的睡不好觉的宝宝，也许只是因为大脑皮层活跃，无法自我调整进入深睡状态。何必奢望自己的宝宝是能够自行完成调整的那一个？在断奶之后，或随着宝宝的成长，这些现象总归会解决的。<br>最后要提醒妈妈的是：哭闹或烦躁不安时可采取轻拍或抚摸孩子，或给他喂奶和喝水，可使宝宝重新入睡。不要马上又抱又哄，这样会恶性循环。某些神经类型的正常小儿晚上睡眠很差，但只要吃、发育增长没问题就不必太担心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宝宝晚上睡不安的原因很多，应该可以分为两大类：&lt;br&gt;
一、外在因素&lt;br&gt;
1、饥饿&lt;br&gt;
多见于新生儿和三个月之内的宝宝。这时需要哺乳或喂奶来解决。稍大的宝宝如果睡前吃饱，可以排除这个因素。&lt;br&gt;
天气干燥的情况下，宝宝夜间可能会口渴，给他补充点水分可以让他安静。&lt;
      
    
    </summary>
    
      <category term="Life" scheme="https://bobit.github.io/categories/Life/"/>
    
    
      <category term="life" scheme="https://bobit.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>0-12个月宝宝每月注意事项</title>
    <link href="https://bobit.github.io/posts/3892ebd9.html"/>
    <id>https://bobit.github.io/posts/3892ebd9.html</id>
    <published>2016-12-14T23:38:11.000Z</published>
    <updated>2018-12-21T13:33:46.808Z</updated>
    
    <content type="html"><![CDATA[<p>一个月<br>1、24小时内要接种乙肝疫苗、卡介苗<br>2、每天可以睡16—20小时<br>3、不要枕枕头，把毛巾折两折枕，三个月后给宝宝枕枕头，枕高3到4厘米.<br>4、母乳喂奶前后半小时不要喂水，稀释胃液影响消化，睡前不喂水。纯母乳喂养6个月内可以不喂水。人工喂养，两餐之间需要喂水。<br>5、早看黑白图片，培养智力，距离眼镜20厘米处，每周换一张照片，直至宝宝有反应。（0—3个月内）<br>6、新生儿期间，按需喂养。</p><p>两个月<br>1、每个乳房喂奶10—15分钟，每三小时喂一次，养成按顿喂养好习惯。<br>2、不要用摇晃的方式哄宝宝睡觉，影响脑发育，造成轻微智力低下。若要哄，可幅度小、有规律、轻柔舒缓、10分钟左右。<br>3、45天可以训练宝宝抬头，每天两次，每次10秒钟，每次俯卧时间不宜超过一分钟<br>4、不要经常抱宝宝，不利于独立性格形成。</p><p>三个月<br>1、上午可以睡1<sub>2次，下午2次，晚上睡1</sub>2个大觉。<br>2、喂奶每天6次，每次100ml~120ml，分6：00、9：30、13：00、14：30、8：00、11：00.。每日喂养总量超过600ml即可。为四月添加辅食培养好习惯。<br>3、陪宝宝发a、e等元音，训练宝宝追视能力。<br>4、给宝宝做按摩，每天洗澡后做抚触按摩，有效促进神经系统发育和锻炼宝宝的感觉系统（益智）。<br>5、预防宝宝经常偏头睡。</p><p>四个月<br>1、给宝宝枕枕头，枕高3~4厘米。<br>2、宝宝游泳可以提高智力。可以增强自信心、增强免疫力、增大肺活量，睡前游泳更可以促进宝宝身高和体重的增加。<br>3、不要看电视超过3分钟，辐射，对眼睛不好。<br>4、训练宝宝视觉，准备纯色的彩色图片，教宝宝认识不同颜色。<br>5、用棉签给宝宝擦牙。<br>6、宝宝若哭，非让抱着才睡，可让宝宝哭个够，一般一周哭的现象就会消失。<br>7、可以喝果汁，每天10ml，用果汁和果肉分离的榨汁机。按1：3（水）的比例将果汁稀释，用60度的温开水稀释，冷却到40度喂宝宝，上午两餐之间喂一次，适应后加至20ml，一周一种水果。<br>8、训练宝宝用手抓东西、训练宝宝嗅觉。<br>9、听三字儿歌学发音。</p><p>五个月<br>1、可加辅食鸡蛋黄（不要鸡蛋清，容易致敏），以蛋黄恰好凝固为宜，用小勺取1/4碾碎，加少量温开水调成糊状，或加入果汁。于喂奶后喂辅食，每次1/4，一周后无过敏，加至1/2蛋黄，再一周加至1个蛋黄。<br>2、适应蛋黄后，可喂养苹果泥、香蕉泥、米汤等，每次一勺。4<sub>7个月喂养半流质食物，7</sub>12个月添加碎菜末、等碎状固体食物。<br>3、此月宝宝出牙，会吃手，应阻止，否则会影响出牙或牙齿排列不整齐，有缝隙。可用磨牙棒，或转移宝宝注意力。<br>4、不要添加淀粉类食物<br>5、训练宝宝发ma、ba等。</p><p>六个月<br>1、不要喝豆浆、不要用牛奶、酸奶代替配方奶。<br>2、宝宝开始有脾气，不要纵容，要让宝宝自己安静下来后，再引导。</p><p>七个月<br>1、保护宝宝牙齿，吃完奶后，喂几口温开水冲洗口腔，棉签粘淡盐水每天早晚帮宝宝清洗牙齿和牙床。<br>2、给宝宝讲故事和看彩色图片书，重复讲一个故事，看宝宝反映。<br>3、宝宝会出现假哭、假笑等来达到自己的目的，妈妈应视情况让宝宝觉得这样做不能达到目的，几次之后，宝宝就不会再这样了。如不然，宝宝就会想办法编造更复杂的谎言。<br>4、宝宝扔东西，不是惹你生气，开始时是因为发育不全拿不稳，妈妈不应生气，应和宝宝玩扔东西的游戏，适当加以引导。<br>5、宝宝怕生人，出现依恋，可给予更多陪伴和引导。</p><p>八个月<br>1、不要给宝宝喝糖水、冰水<br>2、训练宝宝用小勺<br>3、宝宝会出现很多重复的动作，如反复摆同一积木，不要阻止。<br>4、不要告诉宝宝“天黑，外面有鬼之类的话”宝宝以后会怕黑，胆子小，不敢独处。</p><p>九个月<br>1、可以吃面食、小馒头等<br>2、6个月前纯母乳喂养的宝宝可以不喝水、6个月后的宝宝不要喝纯净水和矿泉水，喝煮好的温开水。<br>3、不要给宝宝吃膨化食品、爆米花、松花蛋、油条、腌制食品、味精多的食品，会影响宝宝智力。<br>4、经常锻炼宝宝的爬行能力，不要急于让宝宝行走。爬好了，才能走。</p><p>十个月<br>1、不要吃糖和巧克力<br>2、制定宝宝吃饭规则、定时定量定位置，养成良好习惯，否则宝宝容易不爱吃饭，影响发育。坚决不吃零食，吃零食会影响吃正餐。<br>3、和宝宝一起看书、翻书。<br>4、给宝宝准备玩具箱，让宝宝玩完玩具自己放回去。可以告诉他，小球回家了。<br>5、培养宝宝乐感，每天10~15分钟古典音乐，宝宝爬行时可以放有节奏的音乐。<br>6、做游戏激发宝宝好奇心，可以将搭好的积木推到，再陪宝宝搭、可以让宝宝找小球。</p><p>十一个月<br>1、学习站立，摔倒了，鼓励宝宝站起来继续走。<br>2、给宝宝营造独立思考的环境，宝宝玩玩具或积木时不要打扰，若买了新玩具看见宝宝还在玩别的玩具，也不要打断宝宝，等宝宝不玩后，再告诉宝宝玩新玩具，不然宝宝会对什么事情都不专心，会习惯浅尝辄止。<br>3、看图片学动物叫<br>4、不要使用学步车<br>5、宝宝任性不能纵容，可转移宝宝注意力，或等宝宝安静下来再处理。</p><p>十二个月<br>1、让宝宝多翻书，可以锻炼手指灵活，陪宝宝看书识字，每天坚持看，养成宝宝主动看书的习惯。<br>2、训练宝宝自己走，宝宝摔倒了，一定不要扶，忍痛引导宝宝自己起来，开始时宝宝会很慢，慢慢会自己起，这样的宝宝坚强、独立。<br>3、给宝宝说话的机会，如宝宝如果想拿杯子，不要马上递给他，要鼓励宝宝说出来。要经常训练宝宝说话的机会，12<sub>24个月是宝宝口语的表达阶段，应训练宝宝主动表达自己的需求。学习口语最佳时间是2</sub>4岁，所以不用等上学再学习英语。<br>4、光脚丫走路好处多</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个月&lt;br&gt;
1、24小时内要接种乙肝疫苗、卡介苗&lt;br&gt;
2、每天可以睡16—20小时&lt;br&gt;
3、不要枕枕头，把毛巾折两折枕，三个月后给宝宝枕枕头，枕高3到4厘米.&lt;br&gt;
4、母乳喂奶前后半小时不要喂水，稀释胃液影响消化，睡前不喂水。纯母乳喂养6个月内可以不喂水。人
      
    
    </summary>
    
      <category term="Life" scheme="https://bobit.github.io/categories/Life/"/>
    
    
      <category term="life" scheme="https://bobit.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习总结</title>
    <link href="https://bobit.github.io/posts/276848db.html"/>
    <id>https://bobit.github.io/posts/276848db.html</id>
    <published>2016-12-13T14:09:17.000Z</published>
    <updated>2018-12-21T12:55:42.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Redis 是一款依据BSD开源协议发行的高性能Key-Value存储系统（cache and store）。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(hashes), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave。Redis并用于构建高性能，可扩展的Web应用程序的完美解决方案。</p><h2 id="主要特点"><a class="markdownIt-Anchor" href="#主要特点"></a> 主要特点</h2><p>Redis从它的许多竞争继承来的三个主要特点：<br>Redis数据库完全在内存中，使用磁盘仅用于持久性。<br>相比许多键值数据存储，Redis拥有一套较为丰富的数据类型。<br>Redis可以将数据复制到任意数量的从服务器。</p><h2 id="redis-优势"><a class="markdownIt-Anchor" href="#redis-优势"></a> Redis 优势</h2><p>异常快速：Redis的速度非常快，每秒能执行约11万集合，每秒约81000+条记录。<br>支持丰富的数据类型：Redis支持最大多数开发人员已经知道像列表，集合，有序集合，散列数据类型。这使得它非常容易解决各种各样的问题，因为我们知道哪些问题是可以处理通过它的数据类型更好。<br>操作都是原子性：所有Redis操作是原子的，这保证了如果两个客户端同时访问的Redis服务器将获得更新后的值。<br>多功能实用工具：Redis是一个多实用的工具，可以在多个用例如缓存，消息，队列使用(Redis原生支持发布/订阅)，任何短暂的数据，应用程序，如Web应用程序会话，网页命中计数等。</p><h2 id="安装redis"><a class="markdownIt-Anchor" href="#安装redis"></a> 安装Redis</h2><p>官方网站：<a href="http://redis.io/" target="_blank" rel="noopener">http://redis.io/</a><br>官方下载：<a href="http://redis.io/download" target="_blank" rel="noopener">http://redis.io/download</a> 可以根据需要下载不同版本<br>windows版：<a href="https://github.com/mythz/redis-windows" target="_blank" rel="noopener">https://github.com/mythz/redis-windows</a></p><p>Windows 64位操作系统<br>Redis 安装包<br>下载完成后 可以右键解压到 某个硬盘下 比如D:\Redis\redis-2.6。<br>在D:\Redis\redis-2.6\bin\release下 有两个zip包 一个32位一个64位。<br>根据自己windows的位数 解压到D:\Redis\redis-2.6 根目录下。</p><p>文件介绍：<br>redis-benchmark.exe         #基准测试<br>redis-check-aof.exe         # aof<br>redischeck-dump.exe        # dump<br>redis-cli.exe               # 客户端<br>redis-server.exe            # 服务器<br>redis.windows.conf          # 配置文件</p><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2><p>redis-desktop-manager-0.8.3.3850.exe<br>Windows下Redis的安装使用</p><h2 id="启动redis"><a class="markdownIt-Anchor" href="#启动redis"></a> 启动Redis</h2><p>进入redis目录后 开启服务  （注意加上redis.conf）<br>redis-server.exe redis.windows.conf<br>这个窗口要保持开启  关闭时redis服务会自动关闭<br>redis会自动保存数据到硬盘 所以图中是我第二次开启时 多了一个 DB loaded from disk</p><h2 id="测试使用"><a class="markdownIt-Anchor" href="#测试使用"></a> 测试使用</h2><p>另外开启一个命令行窗口 进入redis目录下 （注意修改自己的ip）<br>redis-cli.exe（默认为127.0.0.1:6379）<br>redis-cli.exe -h 192.168.10.61 -p 6379<br>redis-cli.exe -h 192.168.80.72 -p 6379</p><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name zhangsan</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>将Redis设为windows启动项<br>win7下安装完redis之后，每次开机都得用cmd命令行启动redis，所以就想办法实现开机自启动redis.<br>每次打开命令行启动Redis会很麻烦，把Redis设为windows启动项就不用每次都入命令行了<br>一、把启动命令写入bat<br>在redis的目录下新建一个start.bat文件内容为<br>E:\DevTools\redis64\redis-server.exe E:\DevTools\redis64\redis.windows.conf<br>二、利用vb脚本调用bat<br>再新建一个文件redis_run.vbs内容为<br>CreateObject(“WScript.Shell”).Run “cmd /c E:\DevTools\redis64\start.bat”,0<br>三、设置开机自启动<br>cmd =》 regedit 打开注册表<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run<br>新建一个字符串值，<br>数值名称：startRedis<br>数值数据：E:\DevTools\redis64\start.vbs</p><h2 id="java开发包jedis"><a class="markdownIt-Anchor" href="#java开发包jedis"></a> Java开发包Jedis</h2><h2 id="操作命令总结"><a class="markdownIt-Anchor" href="#操作命令总结"></a> 操作命令总结</h2><p>这篇文章主要介绍了Redis操作命令总结,本文讲解了key pattern 查询相应的key、字符串类型的操作、链表操作、hashes类型及操作、集合结构操作、有序集合、服务器相关命令等内容,需要的朋友可以参考下</p><h3 id="key-pattern-查询相应的key"><a class="markdownIt-Anchor" href="#key-pattern-查询相应的key"></a> key pattern 查询相应的key</h3><p>（1）keys *：redis允许模糊查询key　　有3个通配符  *、?、[]<br>（2）randomkey：返回随机key<br>（3）type key：返回key存储的类型<br>（4）exists key：判断某个key是否存在（1:存在，0：不存在）<br>（5）del key：删除key<br>（6）rename key newkey：改名<br>（7）renamenx key newkey：如果newkey不存在则修改成功<br>（8）move key 1：将key移动到1数据库<br>（9）ttl key：查询key的生命周期（秒）<br>（10）expire key 整数值：设置key的生命周期以秒为单位<br>（11）pexpire key 整数值：设置key的生命周期以毫秒为单位<br>（12）pttl key：查询key 的生命周期（毫秒）<br>（13）perisist key：把指定key设置为永久有效</p><h3 id="字符串类型的操作"><a class="markdownIt-Anchor" href="#字符串类型的操作"></a> 字符串类型的操作</h3><p>（1）set key value [ex 秒数] [px 毫秒数] [nx/xx]<br>如果ex和px同时写，则以后面的有效期为准<br>nx：如果key不存在则建立<br>xx：如果key存在则修改其值<br>（2）get key：取值<br>（3）mset key1 value1 key2 value2 一次设置多个值<br>（4）mget key1 key2 ：一次获取多个值<br>（5）setrange key offset value：把字符串的offset偏移字节改成value<br>如果偏移量 &gt; 字符串长度，该字符自动补0x00<br>（6）append key value ：把value追加到key 的原值上<br>（7）getrange key start stop：获取字符串中[start, stop]范围的值<br>对于字符串的下标，左数从0开始，右数从-1开始<br>注意：当start&gt;length，则返回空字符串<br>当stop&gt;=length，则截取至字符串尾<br>如果start所处位置在stop右边，则返回空字符串<br>（8）getset key nrevalue：获取并返回旧值，在设置新值<br>（9）incr key：自增，返回新值，如果incr一个不是int的value则返回错误，incr一个不存在的key，则设置key为1<br>（10）incrby key 2：跳2自增<br>（11）incrbyfloat by 0.7： 自增浮点数<br>（12）setbit key offset value：设置offset对应二进制上的值，返回该位上的旧值<br>注意：如果offset过大，则会在中间填充0<br>offset最大到多少<br>2^32-1，即可推出最大的字符串为512M<br>（13）bitop operation destkey key1 [key2…]    对key1 key2做opecation并将结果保存在destkey上<br>opecation可以是AND OR NOT XOR<br>（14）strlen key：取指定key的value值的长度<br>（15）setex key time value：设置key对应的值value，并设置有效期为time秒</p><h3 id="链表操作"><a class="markdownIt-Anchor" href="#链表操作"></a> 链表操作</h3><p>Redis的list类型其实就是一个每个子元素都是string类型的双向链表，链表的最大长度是2^32。list既可以用做栈，也可以用做队列。<br>list的pop操作还有阻塞版本，主要是为了避免轮询<br>（1）lpush key value：把值插入到链表头部<br>（2）rpush key value：把值插入到链表尾部<br>（3）lpop key ：返回并删除链表头部元素<br>（4）rpop key： 返回并删除链表尾部元素<br>（5）lrange key start stop：返回链表中[start, stop]中的元素<br>（6）lrem key count value：从链表中删除value值，删除count的绝对值个value后结束<br>count &gt; 0 从表头删除　　count &lt; 0 从表尾删除　　count=0 全部删除<br>（7）ltrim key start stop：剪切key对应的链接，切[start, stop]一段并把改制重新赋给key<br>（8）lindex key index：返回index索引上的值<br>（9）llen key：计算链表的元素个数<br>（10）linsert key after|before search value：在key 链表中寻找search，并在search值之前|之后插入value<br>（11）rpoplpush source dest：把source 的末尾拿出，放到dest头部，并返回单元值</p><p>应用场景： task + bak 双链表完成安全队列<br>业务逻辑： rpoplpush task bak<br>接收返回值并做业务处理</p><p>如果成功则rpop bak清除任务，如果不成功，下次从bak表取任务<br>（12）brpop，blpop key timeout：等待弹出key的尾/头元素<br>timeout为等待超时时间，如果timeout为0则一直等待下去<br>应用场景：长轮询ajax，在线聊天时能用到</p><h3 id="hashes类型及操作"><a class="markdownIt-Anchor" href="#hashes类型及操作"></a> hashes类型及操作</h3><p>Redis hash 是一个string类型的field和value的映射表，它的添加、删除操作都是O(1)（平均）。hash特别适用于存储对象，将一个对象存储在hash类型中会占用更少的内存，并且可以方便的存取整个对象。</p><p>配置： hash_max_zipmap_entries 64 #配置字段最多64个<br>hash_max_zipmap_value 512 #配置value最大为512字节<br>（1）hset myhash field value：设置myhash的field为value<br>（2）hsetnx myhash field value：不存在的情况下设置myhash的field为value<br>（3）hmset myhash field1 value1 field2 value2：同时设置多个field<br>（4）hget myhash field：获取指定的hash field<br>（5）hmget myhash field1 field2：一次获取多个field<br>（6）hincrby myhash field 5：指定的hash field加上给定的值<br>（7）hexists myhash field：测试指定的field是否存在<br>（8）hlen myhash：返回hash的field数量<br>（9）hdel myhash field：删除指定的field<br>（10）hkeys myhash：返回hash所有的field<br>（11）hvals myhash：返回hash所有的value<br>（12）hgetall myhash：获取某个hash中全部的field及value</p><h3 id="集合结构操作"><a class="markdownIt-Anchor" href="#集合结构操作"></a> 集合结构操作</h3><p>特点：无序性、确定性、唯一性<br>（1）sadd key value1 value2：往集合里面添加元素<br>（2）smembers key：获取集合所有的元素<br>（3）srem key value：删除集合某个元素<br>（4）spop key：返回并删除集合中1个随机元素（可以坐抽奖，不会重复抽到某人）<br>（5）srandmember key：随机取一个元素<br>（6）sismember key value：判断集合是否有某个值<br>（7）scard key：返回集合元素的个数<br>（8）smove source dest value：把source的value移动到dest集合中<br>（9）sinter key1 key2 key3：求key1 key2 key3的交集<br>（10）sunion key1 key2：求key1 key2 的并集<br>（11）sdiff key1 key2：求key1 key2的差集<br>（12）sinterstore res key1 key2：求key1 key2的交集并存在res里</p><h3 id="有序集合"><a class="markdownIt-Anchor" href="#有序集合"></a> 有序集合</h3><p>概念：它是在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动按新的值调整顺序。可以理解为有两列的mysql表，一列存储value，一列存储顺序，操作中key理解为zset的名字。</p><p>和set一样sorted，sets也是string类型元素的集合，不同的是每个元素都会关联一个double型的score。sorted set的实现是skip list和hash table的混合体。</p><p>当元素被添加到集合中时，一个元素到score的映射被添加到hash table中，所以给定一个元素获取score的开销是O(1)。另一个score到元素的映射被添加的skip list，并按照score排序，所以就可以有序地获取集合中的元素。添加、删除操作开销都是O(logN)和skip list的开销一致，redis的skip list 实现是双向链表，这样就可以逆序从尾部去元素。sorted set最经常使用方式应该就是作为索引来使用，我们可以把要排序的字段作为score存储，对象的ID当元素存储。<br>（1）zadd key score1 value1：添加元素<br>（2）zrange key start stop [withscore]：把集合排序后,返回名次[start,stop]的元素  默认是升续排列  withscores 是把score也打印出来<br>（3）zrank key member：查询member的排名（升序0名开始）<br>（4）zrangebyscore key min max [withscores] limit offset N：集合（升序）排序后取score在[min, max]内的元素，并跳过offset个，取出N个<br>（5）zrevrank key member：查询member排名（降序 0名开始）<br>（6）zremrangebyscore key min max：按照score来删除元素，删除score在[min, max]之间<br>（7）zrem key value1 value2：删除集合中的元素<br>（8）zremrangebyrank key start end：按排名删除元素，删除名次在[start, end]之间的<br>（9）zcard key：返回集合元素的个数<br>（10）zcount key min max：返回[min, max]区间内元素数量<br>（11）zinterstore dest numkeys key1[key2…] [WEIGHTS weight1 [weight2…]] [AGGREGATE SUM|MIN|MAX]</p><p>求key1，key2的交集，key1，key2的权值分别是weight1，weight2<br>聚合方法用 sum|min|max<br>聚合结果 保存子dest集合内<br>注意：weights,aggregate如何理解？<br>答：如果有交集，交集元素又有score，score怎么处理？aggregate num-&gt;score相加，min最小score，max最大score，另外可以通过weights设置不同的key的权重，交集时  score*weight</p><h3 id="服务器相关命令"><a class="markdownIt-Anchor" href="#服务器相关命令"></a> 服务器相关命令</h3><p>（1）ping：测定连接是否存活<br>（2）echo：在命令行打印一些内容<br>（3）select：选择数据库<br>（4）quit：退出连接<br>（5）dbsize：返回当前数据库中key的数目<br>（6）info：获取服务器的信息和统计<br>（7）monitor：实时转储收到的请求<br>（8）config get 配置项：获取服务器配置的信息<br>config set 配置项  值：设置配置项信息<br>（9）flushdb：删除当前选择数据库中所有的key<br>（10）flushall：删除所有数据库中的所有的key<br>（11）time：显示服务器时间，时间戳（秒），微秒数<br>（12）bgrewriteaof：后台保存rdb快照<br>（13）bgsave：后台保存rdb快照<br>（14）save：保存rdb快照<br>（15）lastsave：上次保存时间<br>（16）shutdown [save/nosave]<br>注意：如果不小心运行了flushall，立即shutdown nosave，关闭服务器，然后手工编辑aof文件，去掉文件中的flushall相关行，然后开启服务器，就可以倒回原来是数据。如果flushall之后，系统恰好bgwriteaof了，那么aof就清空了，数据丢失。</p><p>（17）showlog：显示慢查询<br>问：多慢才叫慢？<br>答：由slowlog-log-slower-than 10000，来指定（单位为微秒）<br>问：服务器存储多少条慢查询记录<br>答：由slowlog-max-len 128，来做限制</p><h3 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h3><p>查看匹配前缀的keys<br>keys “key*”</p><p>查看当前所有key<br>keys *</p><p>当前的key是否存在（返回0不存在，1存在）<br>exists key</p><p>删除当前key<br>del key</p><p>设置过期时间<br>expire key 10</p><p>重命名key<br>rename key newkey</p><p>数据库切换<br>select ad4databank</p><p>当前数据库中key的数量<br>dbsize</p><p>清空当前数据库<br>flushdb</p><p>清除所有数据库<br>flushall</p><p>清空redis<br>flushdb</p><p>随机取出一个key<br>randomkey</p><p>查看key的类型<br>type key</p><p>查看数据库中key的数量<br>dbsize</p><p>查看服务器信息<br>info</p><p>查看redis正在做什么<br>monitor</p><p>查看日志<br>slowlog get<br>slowlog get 10</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;Redis 是一款依据BSD开源协议发行的高性能Key-Value存储系统（cache and store）。它通常被称为数据结构服务器，因为值
      
    
    </summary>
    
      <category term="分布式" scheme="https://bobit.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Redis" scheme="https://bobit.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MQ学习总结</title>
    <link href="https://bobit.github.io/posts/2da7d583.html"/>
    <id>https://bobit.github.io/posts/2da7d583.html</id>
    <published>2016-11-13T03:38:35.000Z</published>
    <updated>2018-12-21T12:55:28.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消 息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。其中较为成熟的MQ产品有IBM WEBSPHERE MQ。还有：MSMQ.ActiveMQ. RabbitMQ.ZeroMQ.</p><p>MQ特点<br>MQ是消费-生产者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取或者订阅队列中的消息。MQ和JMS类似，但不同的是JMS是SUN JAVA消息中间件服务的一个标准和API定义，而MQ则是遵循了AMQP协议的具体实现和产品。</p><p>使用场景<br>在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。</p><p>MOM：企业消息系统，即面向消息的中间件，提供了以松散耦合的灵活方式集成应用程序的一种机制。它们提供了基于存储和转发的应用程序之间的异步数据发送，即应用程序彼此不直接通信，而是与作为中介的MOM通信。</p><p>JMS：是Java平台上有关面向消息中间件的技术规范。</p><p>ActiveMQ：ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。可以理解为ActiveMQ是支持jms规范的一个server；相对于对于JDBC和数据库的关系来说，它就是个mysql。</p><h2 id="activemq"><a class="markdownIt-Anchor" href="#activemq"></a> ActiveMQ</h2><h3 id="下载"><a class="markdownIt-Anchor" href="#下载"></a> 下载</h3><p><a href="http://activemq.apache.org/download.html" target="_blank" rel="noopener">http://activemq.apache.org/download.html</a></p><h3 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h3><p>解压缩，运行bin目录下的activemq.bat文件，此时使用的是默认的服务端口：61616和默认的console端口：8161。<br>运行起来后，可以用IE访问:<a href="https://link.jianshu.com?t=http://localhost:8161/admin/index.jsp" target="_blank" rel="noopener">http://localhost:8161/admin/index.jsp</a><br>然后创建一个Queue，命名为FirstQueue。</p><h3 id="修改activemq的服务端口和console端口"><a class="markdownIt-Anchor" href="#修改activemq的服务端口和console端口"></a> 修改ActiveMQ的服务端口和console端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A、修改服务端口：打开conf/activemq.xml文件，修改以下红色字体部分        &lt;transportConnectors&gt;</span><br><span class="line">&lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://10.42.220.72:61618&quot;discoveryUri=&quot;multicast://default&quot;/&gt;</span><br><span class="line">&lt;/transportConnectors&gt;</span><br><span class="line">B、修改console的地址和端口:打开conf/jetty.xml文件，修改以下红色字体部分</span><br><span class="line">&lt;bean id=&quot;jettyPort&quot;class=&quot;org.apache.activemq.web.WebConsolePort&quot;init-method=&quot;start&quot;&gt;</span><br><span class="line">&lt;property name=&quot;port&quot; value=&quot;8162&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="activemq的特性"><a class="markdownIt-Anchor" href="#activemq的特性"></a> activemq的特性</h3><ol><li>多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li><li>完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务)</li><li>对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性</li><li>通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resourceadaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE1.4商业服务器上</li><li>支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li><li>支持通过JDBC和journal提供高速的消息持久化</li><li>从设计上保证了高性能的集群,客户端-服务器,点对点</li><li>支持Ajax</li><li>支持与Axis的整合</li><li>可以很容易得调用内嵌JMS provider,进行测试</li></ol><h3 id="客户端demo"><a class="markdownIt-Anchor" href="#客户端demo"></a> 客户端demo</h3><p>需要提前将activemq解压包中的lib目录下的相关包引入到工程中，再进行如下编码：</p><h4 id="发送端的代码"><a class="markdownIt-Anchor" href="#发送端的代码"></a> 发送端的代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">importjavax.jms.Connection;</span><br><span class="line">importjavax.jms.ConnectionFactory;</span><br><span class="line">importjavax.jms.DeliveryMode;</span><br><span class="line">importjavax.jms.Destination;</span><br><span class="line">importjavax.jms.MessageProducer;</span><br><span class="line">importjavax.jms.Session;</span><br><span class="line">importjavax.jms.TextMessage;</span><br><span class="line">importorg.apache.activemq.ActiveMQConnection;</span><br><span class="line">importorg.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line">publicclass Sender &#123;</span><br><span class="line">    privatestaticfinalintSEND_NUMBER = 5;</span><br><span class="line"> </span><br><span class="line">    publicstaticvoid main(String[] args) &#123;</span><br><span class="line">        // ConnectionFactory：连接工厂，JMS用它创建连接</span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line">        // Connection：JMS客户端到JMS Provider的连接</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        // Session：一个发送或接收消息的线程</span><br><span class="line">        Session session;</span><br><span class="line">        // Destination：消息的目的地;消息发送给谁.</span><br><span class="line">        Destination destination;</span><br><span class="line">        // MessageProducer：消息发送者</span><br><span class="line">        MessageProducer producer;</span><br><span class="line">        // TextMessage message;</span><br><span class="line">        //构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar</span><br><span class="line">        connectionFactory = new ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                &quot;failover:(tcp://10.42.220.72:61617,tcp://10.42.220.72:61618)&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            //构造从工厂得到连接对象</span><br><span class="line">            connection =connectionFactory.createConnection();</span><br><span class="line">            //启动</span><br><span class="line">            connection.start();</span><br><span class="line">            //获取操作连接</span><br><span class="line">            session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            //获取session</span><br><span class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</span><br><span class="line">            //得到消息生成者【发送者】</span><br><span class="line">            producer =session.createProducer(destination);</span><br><span class="line">            //设置不持久化，此处学习，实际根据项目决定</span><br><span class="line">           producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line">            //构造消息，此处写死，项目就是参数，或者方法获取</span><br><span class="line">            sendMessage(session, producer);</span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (null != connection)</span><br><span class="line">                    connection.close();</span><br><span class="line">            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    publicstaticvoid sendMessage(Session session,MessageProducer producer)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        for (int i = 1; i &lt;=SEND_NUMBER; i++) &#123;</span><br><span class="line">            TextMessage message = session</span><br><span class="line">                    .createTextMessage(&quot;ActiveMq发送的消息&quot; + i);</span><br><span class="line">            //发送消息到目的地方</span><br><span class="line">            System.out.println(&quot;发送消息：&quot; + &quot;ActiveMq 发送的消息&quot; + i);</span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收端代码"><a class="markdownIt-Anchor" href="#接收端代码"></a> 接收端代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">importjavax.jms.Connection;</span><br><span class="line">importjavax.jms.ConnectionFactory;</span><br><span class="line">importjavax.jms.Destination;</span><br><span class="line">importjavax.jms.MessageConsumer;</span><br><span class="line">importjavax.jms.Session;</span><br><span class="line">importjavax.jms.TextMessage;</span><br><span class="line">importorg.apache.activemq.ActiveMQConnection;</span><br><span class="line">importorg.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"> </span><br><span class="line">publicclass Receive &#123;</span><br><span class="line">    publicstaticvoid main(String[] args) &#123;</span><br><span class="line">        // ConnectionFactory：连接工厂，JMS用它创建连接</span><br><span class="line">        ConnectionFactory connectionFactory;</span><br><span class="line">        // Connection：JMS客户端到JMS Provider的连接</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        // Session：一个发送或接收消息的线程</span><br><span class="line">        Session session;</span><br><span class="line">        // Destination：消息的目的地;消息发送给谁.</span><br><span class="line">        Destination destination;</span><br><span class="line">        //消费者，消息接收者</span><br><span class="line">        MessageConsumer consumer;</span><br><span class="line">        connectionFactory = new ActiveMQConnectionFactory(</span><br><span class="line">                ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line">                &quot;failover:(tcp://10.42.220.72:61617,tcp://10.42.220.72:61618)&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            //构造从工厂得到连接对象</span><br><span class="line">            connection =connectionFactory.createConnection();</span><br><span class="line">            //启动</span><br><span class="line">            connection.start();</span><br><span class="line">            //获取操作连接</span><br><span class="line">            session = connection.createSession(false,</span><br><span class="line">                    Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">            //获取session</span><br><span class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</span><br><span class="line">            consumer =session.createConsumer(destination);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                //设置接收者接收消息的时间，为了便于测试，这里谁定为100s</span><br><span class="line">                TextMessage message =(TextMessage) consumer.receive(100000);</span><br><span class="line">                if (null != message) &#123;</span><br><span class="line">                    System.out.println(&quot;收到消息&quot; + message.getText());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (null != connection)</span><br><span class="line">                    connection.close();</span><br><span class="line">            &#125; catch (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过监控查看消息堆栈的记录"><a class="markdownIt-Anchor" href="#通过监控查看消息堆栈的记录"></a> 通过监控查看消息堆栈的记录</h4><p>登陆http://localhost:8162/admin/queues.jsp，默认的用户名和密码：admin/admin</p><h3 id="activemq的多种部署方式"><a class="markdownIt-Anchor" href="#activemq的多种部署方式"></a> ActiveMQ的多种部署方式</h3><p>单点的ActiveMQ作为企业应用无法满足高可用和集群的需求，所以ActiveMQ提供了master-slave(主备方式)、broker-cluster等多种部署方式，但通过分析多种部署方式之后我认为需要将两种部署方式相结合才能满足我们公司分布式和高可用的需求，所以后面就重点将解如何将两种部署方式相结合。</p><h4 id="master-slave部署方式"><a class="markdownIt-Anchor" href="#master-slave部署方式"></a> Master-Slave部署方式</h4><h5 id="1shared-filesystem-master-slave部署方式"><a class="markdownIt-Anchor" href="#1shared-filesystem-master-slave部署方式"></a> 1）shared filesystem Master-Slave部署方式</h5><p>主要是通过共享存储目录来实现master和slave的热备，所有的ActiveMQ应用都在不断地获取共享目录的控制权，哪个应用抢到了控制权，它就成为master。<br>多个共享存储目录的应用，谁先启动，谁就可以最早取得共享目录的控制权成为master，其他的应用就只能作为slave。</p><h5 id="2shared-database-master-slave方式"><a class="markdownIt-Anchor" href="#2shared-database-master-slave方式"></a> 2）shared database Master-Slave方式</h5><p>与shared filesystem方式类似，只是共享的存储介质由文件系统改成了数据库而已。</p><h5 id="3replicated-leveldb-store方式"><a class="markdownIt-Anchor" href="#3replicated-leveldb-store方式"></a> 3）Replicated LevelDB Store方式</h5><p>这种主备方式是ActiveMQ5.9以后才新增的特性，使用ZooKeeper协调选择一个node作为master。被选择的master broker node开启并接受客户端连接。</p><p>其他node转入slave模式，连接master并同步他们的存储状态。slave不接受客户端连接。所有的存储操作都将被复制到连接至Master的slaves。</p><p>如果master死了，得到了最新更新的slave被允许成为master。fialed node能够重新加入到网络中并连接master进入slave mode。所有需要同步的disk的消息操作都将等待存储状态被复制到其他法定节点的操作完成才能完成。所以，如果你配置了replicas=3，那么法定大小是(3/2)+1=2. Master将会存储并更新然后等待 (2-1)=1个slave存储和更新完成，才汇报success。至于为什么是2-1，熟悉Zookeeper的应该知道，有一个node要作为观擦者存在。</p><p>单一个新的master被选中，你需要至少保障一个法定node在线以能够找到拥有最新状态的node。这个node将会成为新的master。因此，推荐运行至少3个replica nodes，以防止一个node失败了，服务中断。</p><h4 id="broker-cluster部署方式"><a class="markdownIt-Anchor" href="#broker-cluster部署方式"></a> Broker-Cluster部署方式</h4><p>前面的Master-Slave的方式虽然能解决多服务热备的高可用问题，但无法解决负载均衡和分布式的问题。Broker-Cluster的部署方式就可以解决负载均衡的问题。</p><p>Broker-Cluster部署方式中，各个broker通过网络互相连接，并共享queue。当broker-A上面指定的queue-A中接收到一个message处于pending状态，而此时没有consumer连接broker-A时。如果cluster中的broker-B上面由一个consumer在消费queue-A的消息，那么broker-B会先通过内部网络获取到broker-A上面的message，并通知自己的consumer来消费。</p><h5 id="1static-broker-cluster部署"><a class="markdownIt-Anchor" href="#1static-broker-cluster部署"></a> 1）static Broker-Cluster部署</h5><p>在activemq.xml文件中静态指定Broker需要建立桥连接的其他Broker：</p><pre><code>1、  首先在Broker-A节点中添加networkConnector节点：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61617)&quot;duplex=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure>2、  修改Broker-A节点中的服务提供端口为61616：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</span><br><span class="line">&lt;/transportConnectors&gt;</span><br></pre></td></tr></table></figure>3、  在Broker-B节点中添加networkConnector节点：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure>4、  修改Broker-A节点中的服务提供端口为61617：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</span><br><span class="line">&lt;/transportConnectors&gt;</span><br></pre></td></tr></table></figure>5、分别启动Broker-A和Broker-B。</code></pre><h5 id="2dynamic-broker-cluster部署"><a class="markdownIt-Anchor" href="#2dynamic-broker-cluster部署"></a> 2）Dynamic Broker-Cluster部署</h5><p>在activemq.xml文件中不直接指定Broker需要建立桥连接的其他Broker，由activemq在启动后动态查找：</p><pre><code>1、  首先在Broker-A节点中添加networkConnector节点：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                &lt;networkConnectoruri=&quot;multicast://default&quot;</span><br><span class="line">           dynamicOnly=&quot;true&quot;</span><br><span class="line">           networkTTL=&quot;3&quot;</span><br><span class="line">           prefetchSize=&quot;1&quot;</span><br><span class="line">           decreaseNetworkConsumerPriority=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure>2、修改Broker-A节点中的服务提供端口为61616：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616? &quot; discoveryUri=&quot;multicast://default&quot;/&gt;</span><br><span class="line">&lt;/transportConnectors&gt;</span><br></pre></td></tr></table></figure>3、在Broker-B节点中添加networkConnector节点：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                &lt;networkConnectoruri=&quot;multicast://default&quot;</span><br><span class="line">           dynamicOnly=&quot;true&quot;</span><br><span class="line">           networkTTL=&quot;3&quot;</span><br><span class="line">           prefetchSize=&quot;1&quot;</span><br><span class="line">           decreaseNetworkConsumerPriority=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure>4、修改Broker-B节点中的服务提供端口为61617：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617&quot; discoveryUri=&quot;multicast://default&quot;/&gt;</span><br><span class="line">&lt;/transportConnectors&gt;</span><br></pre></td></tr></table></figure>5、启动Broker-A和Broker-B</code></pre><h4 id="master-slave与broker-cluster相结合的部署方式"><a class="markdownIt-Anchor" href="#master-slave与broker-cluster相结合的部署方式"></a> Master-Slave与Broker-Cluster相结合的部署方式</h4><p>可以看到Master-Slave的部署方式虽然解决了高可用的问题，但不支持负载均衡，Broker-Cluster解决了负载均衡，但当其中一个Broker突然宕掉的话，那么存在于该Broker上处于Pending状态的message将会丢失，无法达到高可用的目的。<br>由于目前ActiveMQ官网上并没有一个明确的将两种部署方式相结合的部署方案，所以我尝试者把两者结合起来部署：</p><p>1、部署的配置修改<br>这里以Broker-A + Broker-B建立cluster，Broker-C作为Broker-B的slave为例：</p><p>1）首先在Broker-A节点中添加networkConnector节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt; </span><br><span class="line"></span><br><span class="line">                &lt;networkConnector   uri=&quot;masterslave:(tcp://0.0.0.0:61617,tcp:// 0.0.0.0:61618)&quot; duplex=&quot;false&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure><p>2）修改Broker-A节点中的服务提供端口为61616：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transportConnectors&gt;</span><br><span class="line"></span><br><span class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/transportConnectors&gt;</span><br></pre></td></tr></table></figure><p>3）在Broker-B节点中添加networkConnector节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt; </span><br><span class="line"></span><br><span class="line">                &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure><p>4）修改Broker-B节点中的服务提供端口为61617：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transportConnectors&gt;</span><br><span class="line"></span><br><span class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/transportConnectors&gt;</span><br></pre></td></tr></table></figure><p>5）修改Broker-B节点中的持久化方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;</span><br><span class="line"></span><br><span class="line">     &lt;kahaDB directory=&quot;/localhost/kahadb&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>6）在Broker-C节点中添加networkConnector节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;networkConnectors&gt; </span><br><span class="line"></span><br><span class="line">                &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/networkConnectors&gt;</span><br></pre></td></tr></table></figure><p>7）修改Broker-C节点中的服务提供端口为61618：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transportConnectors&gt;</span><br><span class="line"></span><br><span class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61618?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/transportConnectors&gt;</span><br></pre></td></tr></table></figure><p>8）修改Broker-B节点中的持久化方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;persistenceAdapter&gt;</span><br><span class="line"></span><br><span class="line">     &lt;kahaDB directory=&quot;/localhost/kahadb&quot;/&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/persistenceAdapter&gt;</span><br></pre></td></tr></table></figure><p>9）分别启动broker-A、broker-B、broker-C，因为是broker-B先启动，所以“/localhost/kahadb”目录被lock住，broker-C将一直处于挂起状态，当人为停掉broker-B之后，broker-C将获取目录“/localhost/kahadb”的控制权，重新与broker-A组成cluster提供服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h2&gt;
&lt;p&gt;MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）
      
    
    </summary>
    
      <category term="分布式" scheme="https://bobit.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="MQ" scheme="https://bobit.github.io/tags/MQ/"/>
    
      <category term="ActiveMQ" scheme="https://bobit.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
</feed>
